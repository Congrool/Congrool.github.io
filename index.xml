<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>浙大SEL实验室</title>
    <link>https://Congrool.github.io/</link>
    <description>Recent content on 浙大SEL实验室</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 26 Aug 2022 20:09:00 +0000</lastBuildDate>
    
	<atom:link href="https://Congrool.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于KubeEdge的边缘节点分组管理设计与实现</title>
      <link>https://Congrool.github.io/blog/2022/08/26/%E5%9F%BA%E4%BA%8Ekubeedge%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 26 Aug 2022 20:09:00 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2022/08/26/%E5%9F%BA%E4%BA%8Ekubeedge%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;KubeEdge 1.11版本提供了“边缘节点分组管理”新特性，抽象出了跨地域的应用部署模型。该模型将边缘节点按地区划分为节点组，并将应用所需资源打包成一个整体在节点组上进行部署，降低了边缘应用生命周期管理的复杂度，有效减少运维成本。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多云环境下的资源调度：karmada scheduler的框架和实现</title>
      <link>https://Congrool.github.io/blog/2021/09/22/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6karmada-scheduler%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 22 Sep 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/09/22/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6karmada-scheduler%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;karmada是华为开源的云原生多云容器编排平台，目标是让开发者像使用单个k8s集群一样使用多k8s集群。它的第一个release（v0.1.0）出现在2020年12月，而正式发布则是2021年4月25日在深圳召开的华为开发者大会（HDC.Cloud）2021上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多云环境下的成员集群管理，看看开源项目karmada是如何做到的</title>
      <link>https://Congrool.github.io/blog/2021/09/16/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%88%90%E5%91%98%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEkarmada%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/</link>
      <pubDate>Thu, 16 Sep 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/09/16/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%88%90%E5%91%98%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEkarmada%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;https://www.gartner.com/smarterwithgartner/why-organizations-choose-a-multicloud-strategy/&#34;&gt;Gartner的一份研究报告中&lt;/a&gt;，公有云用户有81%都采用了多云架构。karmada是华为开源的云原生多云容器编排平台，目标是让开发者像使用单个k8s集群一样使用多k8s集群。它的第一个release（v0.1.0）出现在2020年12月，而正式发布则是2021年4月25日在深圳召开的华为开发者大会（HDC.Cloud）2021上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>从karmada API角度分析多云环境下的应用资源编排：设计与实现</title>
      <link>https://Congrool.github.io/blog/2021/09/13/%E4%BB%8Ekarmada-api%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E8%B5%84%E6%BA%90%E7%BC%96%E6%8E%92%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 13 Sep 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/09/13/%E4%BB%8Ekarmada-api%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E8%B5%84%E6%BA%90%E7%BC%96%E6%8E%92%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;karmada是华为开源的云原生多云容器编排平台，目标是让开发者像使用单个k8s集群一样使用多k8s集群。它的第一个release（v0.1.0）出现在2020年12月，而正式发布则是在2021年4月25日，在深圳召开的华为开发者大会（&lt;a href=&#34;http://hdc.cloud/&#34;&gt;HDC.Cloud&lt;/a&gt;）2021上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>karmada上手指南</title>
      <link>https://Congrool.github.io/blog/2021/08/23/karmada%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 23 Aug 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/08/23/karmada%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;karmada是华为开源的云原生多云容器编排平台，目标是让开发者像使用单个k8s集群一样使用多k8s云。它的第一个release（v0.1.0）出现在2020年12月，而正式发布则是在2021年4月25日，在深圳召开的华为开发者大会（HDC.Cloud）2021上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>openyurt源码分析系列（二）：yurttunnel server/agent</title>
      <link>https://Congrool.github.io/blog/2021/05/13/openyurt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%8Cyurttunnel-serveragent/</link>
      <pubDate>Thu, 13 May 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/05/13/openyurt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%8Cyurttunnel-serveragent/</guid>
      <description>&lt;p&gt;本文主要对 OpenYurt 中的 Yurttunnel Server/Agent 模块进行了源码分析，内容包括模块启动流程、各个模块组件的工作流程以及通信。（源码版本：OpenYurt Version: &lt;code&gt;0.3.0&lt;/code&gt;  commit: &lt;code&gt;b3fda60af24ed63d84328417e625ad85c453d4af&lt;/code&gt;）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>openyurt源码分析系列（一）：YurtHub</title>
      <link>https://Congrool.github.io/blog/2021/03/24/openyurt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80yurthub/</link>
      <pubDate>Wed, 24 Mar 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/03/24/openyurt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80yurthub/</guid>
      <description>&lt;p&gt;YurtHub的功能主要是对客户端Request的反向代理。本文基于Openyurt 0.3版本（commit: &lt;code&gt;e1c1651405aeeb61f0ad264a9acdf8d08e917a4d&lt;/code&gt;）的源码，提供了对反向代理功能的解析（不包括YurtHub的本地缓存管理：CacheManager，storage和GC）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeedge源码分析系列（五）：DeviceTwin模块详解</title>
      <link>https://Congrool.github.io/blog/2021/01/25/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%94devicetwin%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 25 Jan 2021 10:05:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/01/25/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%94devicetwin%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;本篇主要从DeviceTwin组件的源码出发，剖析DeviceTwin模块的内部实现，同时也对其四个子模块（membership、communication、device和twin）的具体执行逻辑进行具体分析。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeedge源码分析系列（四）：DeviceController模块详解</title>
      <link>https://Congrool.github.io/blog/2021/01/25/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E5%9B%9Bdevicecontroller%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 25 Jan 2021 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2021/01/25/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E5%9B%9Bdevicecontroller%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;本篇主要剖析了为自定义资源提供各种服务的控制器DeviceController的源码，分别从&lt;code&gt;upstream&lt;/code&gt;和&lt;code&gt;downstream&lt;/code&gt;两个独立的goroutine出发去追寻数据的流动过程。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeedge源码分析系列（三）：edgecore架构</title>
      <link>https://Congrool.github.io/blog/2020/12/21/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%89edgecore%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 21 Dec 2020 10:05:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2020/12/21/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%89edgecore%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;p&gt;本文在commit &lt;code&gt;a9b0862bed7fc2f9350a850496e60640fc43c15c&lt;/code&gt;(2020.06.20)之后对KubeEdge进行源码分析，分析KubeEdge的edgecore的整体框架，对细节不做过多展示。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeedge源码分析系列（二）：cloudhub</title>
      <link>https://Congrool.github.io/blog/2020/12/21/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%8Ccloudhub/</link>
      <pubDate>Mon, 21 Dec 2020 10:00:11 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2020/12/21/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%BA%8Ccloudhub/</guid>
      <description>&lt;p&gt;本文基于KubeEdge官方文档，加上作者的亲身实践，给出以下KubeEdge1.3.0版本下Cloudcore模块中cloudhub模组的源码分析。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubeedge源码分析系列（一）：总体架构分析</title>
      <link>https://Congrool.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 29 Nov 2018 16:55:37 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/11/29/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B8%80%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;kubeedge是华为在KubeCon CloudNativeCon China 2018上发布的面向边缘环境容器管理平台。kubeedge能够接入云端Kubernetes集群，使得边缘端应用的管理可以跟云端应用的管理一样，采用广为熟知的Kubernetes API。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>knative serving开发环境搭建</title>
      <link>https://Congrool.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 11 Oct 2018 20:11:02 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/10/11/knative-serving%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>本文基官方knative serving的开发环境搭建文档，加自己的实践，给出以下knative serving开发环境的搭建方案。</description>
    </item>
    
    <item>
      <title>从containerd pull镜像流程分析oci distribution spec</title>
      <link>https://Congrool.github.io/blog/2018/08/05/%E4%BB%8Econtainerd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/</link>
      <pubDate>Sun, 05 Aug 2018 19:03:13 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/08/05/%E4%BB%8Econtainerd-pull%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90oci-distribution-spec/</guid>
      <description>&lt;p&gt;oci组织成立以来已经形成了关于image和runtime的两个spec。&lt;a href=&#34;https://www.linuxfoundation.org/press-release/2018/04/open-container-initiative-announces-distribution-specification-project/&#34;&gt;2018年4月&lt;/a&gt;，作为与registry交互的镜像分发协议也进入了oci标准化的工作范围。oci以当前被广泛采用的&lt;a href=&#34;https://github.com/docker/distribution/blob/5cb406d511b7b9163bff9b6439072e4892e5ae3b/docs/spec/api.md&#34;&gt;Docker Registry HTTP API V2&lt;/a&gt;为基础，构建了oci distribution spec。containerd当前同时支持docker版的和oci版的registry api。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Service Mesh深度学习系列（三）| xds协议解密</title>
      <link>https://Congrool.github.io/blog/2018/07/27/service-mesh%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89-istio%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bpilot-discovery%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 27 Jul 2018 14:28:25 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/07/27/service-mesh%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89-istio%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bpilot-discovery%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;本文分析的istio代码版本为0.8.0，commit为0cd8d67，commit时间为2018年6月18日。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Service Mesh深度学习系列（二）| istio pilot模块分析</title>
      <link>https://Congrool.github.io/blog/2018/07/13/service-mesh%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C-istio-discovery%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 13 Jul 2018 14:15:16 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/07/13/service-mesh%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C-istio-discovery%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;本文分析的istio代码版本为0.8.0，commit为0cd8d67，commit时间为2018年6月18日。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Service Mesh深度学习系列（一）| istio pilot-agent模块分析</title>
      <link>https://Congrool.github.io/blog/2018/06/26/service-mesh%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80-istio-pilot-agent%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 26 Jun 2018 14:29:18 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/06/26/service-mesh%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80-istio-pilot-agent%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;本文分析的istio代码版本为0.8.0，commit为0cd8d67，commit时间为2018年6月18日。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PouchContainer CRI的设计与实现</title>
      <link>https://Congrool.github.io/blog/2018/05/29/pouchcontainer-cri%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 29 May 2018 10:35:04 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/05/29/pouchcontainer-cri%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h3 id=&#34;1-cri简介&#34;&gt;1. CRI简介&lt;/h3&gt;

&lt;p&gt;在每个Kubernetes节点的最底层都有一个程序负责具体的容器创建删除工作，Kubernetes会对其接口进行调用，从而完成容器的编排调度。我们将这一层软件称之为容器运行时（Container Runtime），大名鼎鼎的Docker就是其中的代表。&lt;/p&gt;

&lt;p&gt;当然，容器运行时并非只有Docker一种，包括CoreOS的rkt，hyper.sh的runV，Google的gvisor，以及本文的主角PouchContainer，都包含了完整的容器操作，能够用来创建特性各异的容器。不同的容器运行时有着各自独特的优点，能够满足不同用户的需求，因此Kubernetes支持多种容器运行时势在必行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入理解Docker容器引擎runC执行框架</title>
      <link>https://Congrool.github.io/blog/2018/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3docker%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8Erunc%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 10 May 2018 10:16:40 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/05/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3docker%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8Erunc%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6/</guid>
      <description>&lt;h2 id=&#34;1-简介&#34;&gt;1 简介&lt;/h2&gt;

&lt;p&gt;根据官方的定义：runC是一个根据OCI标准创建并运行容器的CLI tool。&lt;/p&gt;

&lt;p&gt;Docker就是基于runC创建的，简单地说，runC是Docker中最为核心的部分，容器的创建，运行，销毁等等操作最终都将通过调用runC完成。下面我们将演示如何使用runC，以最精简的方式创建并运行一个容器。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>技术干货|深入理解flannel</title>
      <link>https://Congrool.github.io/blog/2018/03/14/%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3flannel/</link>
      <pubDate>Wed, 14 Mar 2018 11:23:35 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2018/03/14/%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3flannel/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;根据官网的描述，flannel是一个专为kubernetes定制的三层网络解决方案，主要用于解决容器的跨主机通信问题。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes全球代码贡献量排行，浙江大学第六</title>
      <link>https://Congrool.github.io/blog/2016/11/30/k8s%E4%BB%A3%E7%A0%81%E8%B4%A1%E7%8C%AE%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%E7%AC%AC%E5%85%AD/</link>
      <pubDate>Wed, 30 Nov 2016 18:12:46 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2016/11/30/k8s%E4%BB%A3%E7%A0%81%E8%B4%A1%E7%8C%AE%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D%E7%AC%AC%E5%85%AD/</guid>
      <description>全球企业Kubernetes开源社区代码贡献排名：浙江大学SEL实验室排名第六。请看来自Stackalytics|Kubernetes community contribution官方网站截图。</description>
    </item>
    
    <item>
      <title>《Docker容器与容器云》第2版推荐</title>
      <link>https://Congrool.github.io/blog/2016/11/30/docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%E7%AC%AC2%E7%89%88%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Wed, 30 Nov 2016 17:41:43 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2016/11/30/docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%E7%AC%AC2%E7%89%88%E6%8E%A8%E8%8D%90/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;本书根据Docker 1.10版和Kubernetes 1.2版对第1版进行了全面更新，从实践者的角度出发，以Docker和Kubernetes为重点，沿着“基本用法介绍”到“核心原理解读”到“高级实践技巧”的思路，一本书讲透当前主流的容器和容器云技术，有助于读者在实际场景中利用Docker容器和容器云解决问题并启发新的思考。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>《Docker容器与容器云》推荐</title>
      <link>https://Congrool.github.io/blog/2015/10/21/docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Wed, 21 Oct 2015 20:26:10 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/10/21/docker%E5%AE%B9%E5%99%A8%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%91%E6%8E%A8%E8%8D%90/</guid>
      <description>&lt;p&gt;《Docker容器与容器云》是Kubernetes社区核心开发者张磊博士及其技术团队近年来PaaS方面积累，全书不仅描述了容器与容器云技术，还融入了实验室四年来对云计算各个层面的理解。该书是国内第一本对Docker原理进行深度解析的书籍，也是第一本结合PaaS对各类容器云进行深度剖析，并着重深入分析Kubernetes原理的书籍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker背后的标准化容器执行引擎——runC</title>
      <link>https://Congrool.github.io/blog/2015/10/21/docker%E8%83%8C%E5%90%8E%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-runc/</link>
      <pubDate>Wed, 21 Oct 2015 19:44:38 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/10/21/docker%E8%83%8C%E5%90%8E%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E5%AE%B9%E5%99%A8%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-runc/</guid>
      <description>&lt;p&gt;随着容器技术发展的愈发火热，Linux基金会于2015年6月成立&lt;a href=&#34;https://www.opencontainers.org/&#34;&gt;OCI（Open Container Initiative）&lt;/a&gt;组织，旨在围绕容器格式和运行时制定一个开放的工业化标准。该组织一成立便得到了包括谷歌、微软、亚马逊、华为等一系列云计算厂商的支持。而runC就是Docker贡献出来的，按照该开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes apiserver源码分析——api请求的认证过程</title>
      <link>https://Congrool.github.io/blog/2015/08/09/kubernetes-apiserver%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 09 Aug 2015 11:25:44 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/08/09/kubernetes-apiserver%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;解决什么问题&#34;&gt;&lt;strong&gt;解决什么问题&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;笔者之前希望全面分析一下k8apiserver的源码，后来发现这样并不十分有效，其一没有针对性，其二由于代码本身比较复杂，涉及到的功能较多，面面俱到也不太现实。&lt;/p&gt;

&lt;p&gt;于是我们就回到最初的需求，到底需要解决什么问题，第一个问题就是，apiserver启动的时候，使用secure模式，参数应该如何设置，相关的机制又是怎样？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>kubernetes node components - kubelet</title>
      <link>https://Congrool.github.io/blog/2015/08/07/kubernetes-node-components-kubelet/</link>
      <pubDate>Fri, 07 Aug 2015 19:46:42 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/08/07/kubernetes-node-components-kubelet/</guid>
      <description>&lt;p&gt;kubelet作为k8s集群node上的重要组件，一直饱受关注。下面请随笔者一起walk through the code.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>4S: Services Account, Secret, Security Context and Security in Kubernetes</title>
      <link>https://Congrool.github.io/blog/2015/07/30/4s-services-account-secret-security-context-and-security-in-kubernetes/</link>
      <pubDate>Thu, 30 Jul 2015 13:41:07 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/07/30/4s-services-account-secret-security-context-and-security-in-kubernetes/</guid>
      <description>&lt;p&gt;Service Account, Secrets和Security Contexts作为保证kubernetes集群Security的策略被引入，相关代码一直处于快速变更与迭代中。本文谨从design和初级实践的视角对其进行概略性的分析，以飨读者。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>tutum-agent原理浅析</title>
      <link>https://Congrool.github.io/blog/2015/06/23/tutum-agent%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 23 Jun 2015 11:14:25 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/06/23/tutum-agent%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</guid>
      <description>tutum-aget是tutum提供的一个开源代理引擎。当你把tutum-agent安装在你本地机器上以后，你就可以把本地的机器节点添加到云端，让tutum来帮你统一进行管理。你随时随地都可以登陆tutum网站获得如下功能。</description>
    </item>
    
    <item>
      <title>Docker背后的容器管理——libcontainer深度解析</title>
      <link>https://Congrool.github.io/blog/2015/06/03/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-libcontainer%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 03 Jun 2015 13:29:26 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/06/03/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-libcontainer%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;libcontainer 是Docker中用于容器管理的包，它基于Go语言实现，通过管理&lt;code&gt;namespaces&lt;/code&gt;、&lt;code&gt;cgroups&lt;/code&gt;、&lt;code&gt;capabilities&lt;/code&gt;以及文件系统来进行容器控制。你可以使用libcontainer创建容器，并对容器进行生命周期管理。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker背后的内核知识——cgroups资源限制</title>
      <link>https://Congrool.github.io/blog/2015/04/22/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86-cgroups%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</link>
      <pubDate>Wed, 22 Apr 2015 10:03:07 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/04/22/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86-cgroups%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;

&lt;p&gt;当我们谈论Docker时，我们常常会聊到Docker的实现方式。很多开发者都会知道，Docker的本质实际上是宿主机上的一个进程，通过namespace实现了资源隔离，通过cgroup实现了资源限制，通过UnionFS实现了Copy on Write的文件操作。但是当我们再深入一步的提出，namespace和cgroup实现细节时，知道的人可能就所剩无几了。本文在docker基础研究工作中着重对内核的cgroup技术做了细致的分析和梳理，希望能对读者深入理解Docker有所帮助。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker背后的内核知识——Namespace资源隔离</title>
      <link>https://Congrool.github.io/blog/2015/03/13/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86-namespace%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</link>
      <pubDate>Fri, 13 Mar 2015 13:54:32 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/03/13/docker%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86-namespace%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB/</guid>
      <description>&lt;p&gt;Docker这么火，喜欢技术的朋友可能也会想，如果要自己实现一个资源隔离的容器，应该从哪些方面下手呢？也许你第一反应可能就是&lt;code&gt;chroot&lt;/code&gt;命令，这条命令给用户最直观的感觉就是使用后根目录&lt;code&gt;/&lt;/code&gt;的挂载点切换了，即文件系统被隔离了。然后，为了在分布式的环境下进行通信和定位，容器必然需要一个独立的IP、端口、路由等等，自然就想到了网络的隔离。同时，你的容器还需要一个独立的主机名以便在网络中标识自己。想到网络，顺其自然就想到通信，也就想到了进程间通信的隔离。可能你也想到了权限的问题，对用户和用户组的隔离就实现了用户权限的隔离。最后，运行在容器中的应用需要有自己的&lt;code&gt;PID&lt;/code&gt;,自然也需要与宿主机中的&lt;code&gt;PID&lt;/code&gt;进行隔离。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（九）：Docker镜像</title>
      <link>https://Congrool.github.io/blog/2015/03/12/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%9Ddocker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Thu, 12 Mar 2015 20:16:14 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/03/12/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%9Ddocker%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;h2 id=&#34;1-前言&#34;&gt;&lt;strong&gt;1.前言&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;回首过去的2014年，大家可以看到Docker在全球刮起了一阵又一阵的“容器风”，工业界对Docker的探索与实践更是一波高过一波。在如今的2015年以及未来，Docker似乎并不会像其他昙花一现的技术一样，在历史的舞台上热潮褪去，反而在工业界实践与评估之后，显现了前所未有的发展潜力。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（八）：Docker Container网络（下）</title>
      <link>https://Congrool.github.io/blog/2015/03/12/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%ABdocker-container%E7%BD%91%E7%BB%9C%E4%B8%8B/</link>
      <pubDate>Thu, 12 Mar 2015 20:03:21 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/03/12/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%ABdocker-container%E7%BD%91%E7%BB%9C%E4%B8%8B/</guid>
      <description>&lt;h2 id=&#34;1-docker-client配置容器网络模式&#34;&gt;&lt;strong&gt;1.Docker Client配置容器网络模式&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Docker目前支持4种网络模式，分别是bridge、host、container、none，Docker开发者可以根据自己的需求来确定最适合自己应用场景的网络模式。 从Docker Container网络创建流程图中可以看到，创建流程第一个涉及的Docker模块即为Docker Client。当然，这也十分好理解，毕竟Docker Container网络环境的创建需要由用户发起，用户根据自身对容器的需求，选择网络模式，并将其通过Docker Client传递给Docker Daemon。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>etcd：从应用场景到实现原理的全方位解读</title>
      <link>https://Congrool.github.io/blog/2015/02/01/etcd%E4%BB%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BB/</link>
      <pubDate>Sun, 01 Feb 2015 15:27:24 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/02/01/etcd%E4%BB%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%9A%84%E5%85%A8%E6%96%B9%E4%BD%8D%E8%A7%A3%E8%AF%BB/</guid>
      <description>&lt;p&gt;随着CoreOS和Kubernetes等项目在开源社区日益火热，它们项目中都用到的etcd组件作为一个高可用、强一致性的服务发现存储仓库，渐渐为开发人员所关注。在云计算时代，如何让服务快速透明地接入到计算集群中，如何让共享配置信息快速被集群中的所有机器发现，更为重要的是，如何构建这样一套高可用、安全、易于部署以及响应快速的服务集群，已经成为了迫切需要解决的问题。etcd为解决这类问题带来了福音，本章将从etcd的应用场景开始，深入解读etcd的实现方式，以供开发者们更为充分地享用etcd所带来的便利。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（七）：Docker Container网络 （上）</title>
      <link>https://Congrool.github.io/blog/2015/01/26/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%83docker-container%E7%BD%91%E7%BB%9C-%E4%B8%8A/</link>
      <pubDate>Mon, 26 Jan 2015 10:31:13 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/01/26/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%83docker-container%E7%BD%91%E7%BB%9C-%E4%B8%8A/</guid>
      <description>&lt;h1 id=&#34;1-前言-什么是docker-container&#34;&gt;&lt;strong&gt;1. 前言(什么是Docker Container)&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;如今，Docker技术大行其道，大家在尝试以及玩转Docker的同时，肯定离不开一个概念，那就是“容器”或者“Docker Container”。那么我们首先从实现的角度来看看“容器”或者“Docker Container”到底为何物。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes代码走读之Minion Node 组件 kube-proxy</title>
      <link>https://Congrool.github.io/blog/2015/01/22/kubernetes-minion-node-%E7%BB%84%E4%BB%B6-kube-proxy-%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Thu, 22 Jan 2015 14:16:32 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/01/22/kubernetes-minion-node-%E7%BB%84%E4%BB%B6-kube-proxy-%E7%BB%84%E4%BB%B6/</guid>
      <description>&lt;p&gt;Kube-proxy是kubernetes 里运行在minion节点上的一个组件, 它起的作用是一个服务代理的角色. 本文的内容将分为以下两部分, 源代码来自kubernetes release-0.8.1, 代码有删节，省略的代码或log输出用．．．表示:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1 Kube-proxy 简介&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2 Kube-proxy代码解读&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker网络详解及pipework源码解读与实践</title>
      <link>https://Congrool.github.io/blog/2015/01/16/docker%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3%E5%8F%8Apipework%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Fri, 16 Jan 2015 14:20:20 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/01/16/docker%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3%E5%8F%8Apipework%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;p&gt;Docker作为目前最火的轻量级容器技术，有很多令人称道的功能，如Docker的镜像管理。然而，Docker同样有着很多不完善的地方，网络方面就是Docker比较薄弱的部分。因此，我们有必要深入了解Docker的网络知识，以满足更高的网络需求。本文首先介绍了Docker自身的4种网络工作方式，然后通过3个样例 —— 将Docker容器配置到本地网络环境中、单主机Docker容器的VLAN划分、多主机Docker容器的VLAN划分，演示了如何使用&lt;a href=&#34;https://github.com/jpetazzo/pipework&#34;&gt;pipework&lt;/a&gt;帮助我们进行复杂的网络设置，以及pipework是如何工作的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes Minion Node 组件 之 Kubelet</title>
      <link>https://Congrool.github.io/blog/2015/01/13/kubernetes-minion-node-%E7%BB%84%E4%BB%B6-%E4%B9%8B-kubelet/</link>
      <pubDate>Tue, 13 Jan 2015 15:50:51 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/01/13/kubernetes-minion-node-%E7%BB%84%E4%BB%B6-%E4%B9%8B-kubelet/</guid>
      <description>&lt;p&gt;Kubelet是Google Kubernetes 集群minion工作节点上的一个重要组件.本文将作者阅读代码和亲身的使用经验相结合带你深入理解kubelet. 因为kubernetes代码处在火热迭代开发中,版本日新月异, 本文的源代码来自2014年12月22日github上kubernetes的master最新代码, commit id 119fe37f064905d, 由于kubelet代码量大,变量多,所以文中展示的代码有删节,省略的部分用&amp;hellip;表示.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（六）：Docker Daemon网络</title>
      <link>https://Congrool.github.io/blog/2015/01/05/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%ADdocker-daemon%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 05 Jan 2015 10:52:28 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/01/05/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%85%ADdocker-daemon%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt; Docker的容器特性和镜像特性已然为Docker实践者带来了诸多效益，然而Docker的网络特性却不能让用户满意。本文从Docker的网络模式入手，分析了Docker Daemon创建网络环境的详细流程，其中着重于分析Docker桥接模式的创建，为之后Docker Container创建网络环境做铺垫。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Kubernetes设计文档之Volumes</title>
      <link>https://Congrool.github.io/blog/2015/01/02/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8Bvolumes/</link>
      <pubDate>Fri, 02 Jan 2015 10:56:38 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2015/01/02/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8Bvolumes/</guid>
      <description>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;Kubernetes是Google开源的容器集群管理系统，构建于Docker之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等功能。本文描述了Kubernetes中Volumes的使用情况，Volume是一个能够被容器访问的目录。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Kubernetes设计文档之网络篇</title>
      <link>https://Congrool.github.io/blog/2014/12/29/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/</link>
      <pubDate>Mon, 29 Dec 2014 15:32:24 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/29/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%AF%87/</guid>
      <description>&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;： Kubernetes是Google开源的容器集群管理系统，构建于Docker之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等功能。其从Docker默认网络模型中独立出来形成了一套自己的网络模型，本文将详细介绍。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Kubernetes设计文档之服务篇</title>
      <link>https://Congrool.github.io/blog/2014/12/23/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AF%87/</link>
      <pubDate>Tue, 23 Dec 2014 10:20:47 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/23/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AF%87/</guid>
      <description>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; Kubernetes是Google开源的容器集群管理系统，构建于Docker之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等功能。 Pod是创建、调度和管理的最小部署单位，本文详细介绍这些Pod之间的通信和调度。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Kubernetes设计文档之Pod篇</title>
      <link>https://Congrool.github.io/blog/2014/12/19/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8Bpod%E7%AF%87/</link>
      <pubDate>Fri, 19 Dec 2014 10:46:07 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/19/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8Bpod%E7%AF%87/</guid>
      <description>&lt;p&gt;摘要：Kubernetes是Google开源的容器集群管理系统，构建于Docker之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等功能。CSDN联合浙江大学SEL实验室共同翻译其设计文档，本文为系列的第二篇：Pod。&lt;/p&gt;

&lt;p&gt;在Kubernetes中，创建、调度和管理的最小部署单位是Pod，而不是容器。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cf-release结构解析</title>
      <link>https://Congrool.github.io/blog/2014/12/17/cf-release%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 17 Dec 2014 16:03:01 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/17/cf-release%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;1-制作时的cf-release结构解析&#34;&gt;1. 制作时的cf-release结构解析&lt;/h2&gt;

&lt;p&gt;此处指的release统一为CloudFoundry官方给出的&lt;a href=&#34;https://github.com/cloudfoundry/cf-release&#34;&gt;cf-release&lt;/a&gt;，不做修改。&lt;/p&gt;

&lt;p&gt;1.1 通过载入cf-release文件夹下config/final.yml文件，获得需要下载release文件的远程服务器网址，默认使用的提供商是s3，地址是：blob.cfblob.com&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩转Docker镜像</title>
      <link>https://Congrool.github.io/blog/2014/12/16/%E7%8E%A9%E8%BD%ACdocker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Tue, 16 Dec 2014 16:15:36 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/16/%E7%8E%A9%E8%BD%ACdocker%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;p&gt;&lt;strong&gt;摘要:&lt;/strong&gt;Docker是基于Go语言开发，通过分层镜像标准化和内核虚拟化技术，使得应用开发者和运维工程师可以以统一的方式跨平台发布应用。镜像是Docker最核心的技术之一，也是应用发布的标准格式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Kubernetes设计文档之安全篇</title>
      <link>https://Congrool.github.io/blog/2014/12/11/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8B%E5%AE%89%E5%85%A8%E7%AF%87/</link>
      <pubDate>Thu, 11 Dec 2014 21:04:21 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/11/google-kubernetes%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E4%B9%8B%E5%AE%89%E5%85%A8%E7%AF%87/</guid>
      <description>&lt;p&gt;摘要：Kubernetes是Google开源的容器集群管理系统，构建于Docker之上，为容器化的应用提供资源调度、部署运行、服务发现、扩容缩容等功能。本文为其设计文档系列的第一篇：安全。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（五）：Docker Server的创建</title>
      <link>https://Congrool.github.io/blog/2014/12/09/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94docker-server%E7%9A%84%E5%88%9B%E5%BB%BA/</link>
      <pubDate>Tue, 09 Dec 2014 13:00:37 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/09/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%94docker-server%E7%9A%84%E5%88%9B%E5%BB%BA/</guid>
      <description>&lt;h1 id=&#34;1-docker-server简介&#34;&gt;&lt;strong&gt;1. Docker Server简介&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Docker架构中，Docker Server是Docker Daemon的重要组成部分。Docker Server最主要的功能是：接受用户通过Docker Client发送的请求，并按照相应的路由规则实现路由分发。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Blue-Green Deployments on Cloud Foundry (利用CloudFoundry实现蓝绿发布)</title>
      <link>https://Congrool.github.io/blog/2014/12/02/blue-green-deployments-on-cloud-foundry-%E5%88%A9%E7%94%A8cloudfoundry%E5%AE%9E%E7%8E%B0%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83/</link>
      <pubDate>Tue, 02 Dec 2014 19:25:20 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/blue-green-deployments-on-cloud-foundry-%E5%88%A9%E7%94%A8cloudfoundry%E5%AE%9E%E7%8E%B0%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;http://www.mattstine.com/2013/07/10/blue-green-deployments-on-cloudfoundry/&#34;&gt;Blue-Green Deployments on Cloud Foundry&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We’ll begin with a basic Spring application named ms-spr-demo. This app takes users to a simple web page announcing the ubiquitous “Hello World!” message. We’ll utilize the cf command-line interface to push the application:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry’s 新容器技术： A Garden Overview</title>
      <link>https://Congrool.github.io/blog/2014/12/02/cloud-foundrys-%E6%96%B0%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF-a-garden-overview/</link>
      <pubDate>Tue, 02 Dec 2014 18:52:46 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/cloud-foundrys-%E6%96%B0%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF-a-garden-overview/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;编译自：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.pivotal.io/cloud-foundry-pivotal/features/cloud-foundry-container-technology-a-garden-overview&#34;&gt;Cloud Foundry’s Container Technology: A Garden Overview&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://underlap.blogspot.com/2014/06/warden-meets-libcontainer.html&#34;&gt;Containers in Cloud Foundry: warden meets libcontainer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CloudFoundry（CF）中很早就使用了VMware研发的Warden容器来负责应用的资源分配隔离和实例调度。可惜的是，这一本来可以成为业界标准和并掀起一阵革命的容器PaaS技术却因为Pivotal的方针路线上的种种原因被后来居上Docker吊打至今。最近CFer有醒悟的迹象，在Warden上进行了大量改进和升级，本文就来一窥CF新容器技术的一些要点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在生产中使用金丝雀部署来进行测试</title>
      <link>https://Congrool.github.io/blog/2014/12/02/%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Tue, 02 Dec 2014 17:26:05 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95/</guid>
      <description>&lt;p&gt;根据Nolio发布的&lt;a href=&#34;http://www.noliosoft.com/resources/videos/webinar/canary/show/1/&#34;&gt;DevOps最佳实践系列中的第一个demo&lt;/a&gt;，很多公司通过路由策略选择性地对部分用户发布新功能从而使用 “金丝雀部署（Canary Deployments）”来测试生产中的软件，并将这一方式作为其可持续交付的一部分。“金丝雀部署”是增量发布的一种类型，它的执行方式是在原有软件生产版本可用的情况下，同时部署一个新的版本。同时运行同一个软件产品的多个版本需要软件针对配置和完美自动化部署进行特别设计。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中warden的架构与实现</title>
      <link>https://Congrool.github.io/blog/2014/12/02/cloud-foundry%E4%B8%ADwarden%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 02 Dec 2014 17:19:09 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/cloud-foundry%E4%B8%ADwarden%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;在Cloud Foundry中，当应用开发者的应用由Cloud Foundry的组件DEA来运行时，应用的资源隔离与控制显得尤为重要，而warden的存在很好得解决了这个问题。&lt;/p&gt;

&lt;p&gt;Cloud Foundry中warden项目的首要目的是提供一套简易的接口来管理隔离的环境，这些隔离的环境可以被称为“容器”，他们可以在CPU使用，内存使用，磁盘使用以及设备访问权限方面做相应的限制。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中DEA与warden通信完成应用端口监听</title>
      <link>https://Congrool.github.io/blog/2014/12/02/cloud-foundry%E4%B8%ADdea%E4%B8%8Ewarden%E9%80%9A%E4%BF%A1%E5%AE%8C%E6%88%90%E5%BA%94%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/</link>
      <pubDate>Tue, 02 Dec 2014 16:55:44 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/cloud-foundry%E4%B8%ADdea%E4%B8%8Ewarden%E9%80%9A%E4%BF%A1%E5%AE%8C%E6%88%90%E5%BA%94%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9B%91%E5%90%AC/</guid>
      <description>&lt;p&gt;在Cloud Foundry v2版本中，DEA为一个用户应用运行的控制模块，而应用的真正运行都是依附于warden。更具体的来说，是DEA接收到Cloud Controller的请求；DEA发送请求给warden server；warden server创建warden container并将用户应用droplet等环境配置好；DEA发送应用启动请求至warden serve；最后warden container执行启动脚本启动应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（四）：Docker Daemon之NewDaemon实现</title>
      <link>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9Bdocker-daemon%E4%B9%8Bnewdaemon%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Tue, 02 Dec 2014 13:03:12 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9B%9Bdocker-daemon%E4%B9%8Bnewdaemon%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;Docker的生态系统日趋完善，开发者群体也在日趋庞大，这让业界对Docker持续抱有极其乐观的态度。然而，对于广大开发者而言，使用Docker这项技术已然不是门槛，享受Docker带来的技术福利已不是困难。如今，如何探寻Docker适应的场景，如何发展Docker周边的技术，以及如何弥合Docker新技术与传统物理机或VM技术的鸿沟，已经占据Docker研究者们的思考与实践。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（三）：Docker Daemon启动</title>
      <link>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89docker-daemon%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Tue, 02 Dec 2014 13:02:44 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89docker-daemon%E5%90%AF%E5%8A%A8/</guid>
      <description>&lt;h1 id=&#34;摘要&#34;&gt;【摘要】&lt;/h1&gt;

&lt;p&gt;Docker作为业界备受推崇的轻量级虚拟化容器管理引擎，其强大的后台能力全凭Docker Daemon。本文从源码出发，介绍了Docker Daemon的启动流程，并深入分析启动流程中每一步骤的实现细节。Docker的运行真可谓，载体为daemon，调度管理由engine，任务执行靠job。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（二）：Docker Client创建与命令执行</title>
      <link>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8Cdocker-client%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Tue, 02 Dec 2014 13:01:39 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8Cdocker-client%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</guid>
      <description>&lt;h1 id=&#34;1-前言&#34;&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;如今，Docker作为业界领先的轻量级虚拟化容器管理引擎，给全球开发者提供了一种新颖、便捷的软件集成测试与部署之道。在团队开发软件时，Docker可以提供可复用的运行环境、灵活的资源配置、便捷的集成测试方法以及一键式的部署方式。可以说，Docker的优势在简化持续集成、运维部署方面体现得淋漓尽致，它完全让开发者从前者中解放出来，把精力真正地倾注在开发上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker源码分析（一）：Docker架构</title>
      <link>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80docker%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Tue, 02 Dec 2014 10:19:09 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/12/02/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80docker%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;1-背景&#34;&gt;&lt;strong&gt;1 背景&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&#34;1-1-docker简介&#34;&gt;&lt;strong&gt;1.1 Docker简介&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Docker是Docker公司开源的一个基于轻量级虚拟化技术的容器引擎项目,整个项目基于Go语言开发，并遵从Apache 2.0协议。目前，Docker可以在容器内部快速自动化部署应用，并可以通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率，并且提升诸如IO等方面的性能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中gorouter对StickySession的支持</title>
      <link>https://Congrool.github.io/blog/2014/11/21/cloud-foundry%E4%B8%ADgorouter%E5%AF%B9stickysession%E7%9A%84%E6%94%AF%E6%8C%81/</link>
      <pubDate>Fri, 21 Nov 2014 13:04:13 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/11/21/cloud-foundry%E4%B8%ADgorouter%E5%AF%B9stickysession%E7%9A%84%E6%94%AF%E6%8C%81/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;Cloud Foundry作为业界出众的PaaS平台，在应用的可扩展性方面做得非常优秀。&lt;/p&gt;

&lt;p&gt;具体来讲，在一个应用需要横向伸展的时候，Cloud Foundry可以轻松地帮助用户做好伸展工作，也就是创建出一个应用的多个实例，多个实例地位相等，多个实例共同为用户服务，多个实例共同分担访问压力。&lt;/p&gt;

&lt;p&gt;大致来说，可以认为是共同分担访问压力，但是也不是针对所有该应用的访问，都进行均衡，分发到不同的应用实例处。譬如：当Cloud Foundry的访问用户访问应用时，第一次的访问，gorouter会将请求分发到应用的某个实例处，但是如果该用户之后的访问都是有状态的，不希望之后的访问会被分发到该应用的其他实例处。针对以上这种情况，Cloud Foundry提供了自己的解决方案，使用StickySession的方式，保证请求依旧分发给指定的应用实例。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中DEA启动应用实例时环境变量的使用</title>
      <link>https://Congrool.github.io/blog/2014/11/20/cloud-foundry%E4%B8%ADdea%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 20 Nov 2014 13:03:30 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/11/20/cloud-foundry%E4%B8%ADdea%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在Cloud Foundry v2中，当应用用户需要启动应用的实例时，用户通过cf CLI向cloud controller发送请求，而cloud controller通过NATS向DEA转发启动请求。真正执行启动事宜的是DEA，DEA主要做的工作为启动一个warden container, 并将droplet等内容拷贝进入container内部，最后配置完指定的环境变量，在这些环境变量下启动应用的启动脚本。&lt;/p&gt;

&lt;p&gt;本文将从阐述Cloud Foundry中DEA如何为应用实例的启动配置环境变量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Haproxy端口映射（client头中URL/HOST修改后转发）</title>
      <link>https://Congrool.github.io/blog/2014/10/28/haproxy%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84client%E5%A4%B4%E4%B8%ADurlhost%E4%BF%AE%E6%94%B9%E5%90%8E%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Tue, 28 Oct 2014 17:02:26 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/10/28/haproxy%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84client%E5%A4%B4%E4%B8%ADurlhost%E4%BF%AE%E6%94%B9%E5%90%8E%E8%BD%AC%E5%8F%91/</guid>
      <description>&lt;p&gt;CloudFoundry是对域名强依赖的云计算集群，没有域名的话几乎无法访问。但是域名备案等事宜所耗时间较长，在上线较为紧急的情况下，就需要实现直接通过“IP+端口”的形式，在公网访问CF集群上部署的APP。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中gorouter源码分析</title>
      <link>https://Congrool.github.io/blog/2014/05/07/cloud-foundry%E4%B8%ADgorouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 07 May 2014 10:20:09 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/05/07/cloud-foundry%E4%B8%ADgorouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;在Cloud Foundry v1版本中，router作为路由节点，转发所有进入Cloud Foundry的请求。由于开发语言为ruby，故router接受并处理并发请求的能力受到语言层的限制。虽然在v1版本中，router曾经有过一定的优化，采用lua脚本代替原先的ruby脚本，由lua来分析请求，使得一部分请求不再经过ruby代码，而直接去DEA访问应用，但是，一旦router暴露在大量的访问请求下，性能依旧是不尽如人意.&lt;/p&gt;

&lt;p&gt;为了提高Cloud Foundry router的可用性，Cloud Foundry开源社区不久前推出了gorouter。gorouter采用现阶段比较新颖的go作为编程语言，并重新设计了原有的组件架构。由于go语言本身的特性，gorouter处理并发请求的能力大大超过了router，甚至在同种实验环境下，性能是原先router的20倍左右。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中collector组件的源码分析</title>
      <link>https://Congrool.github.io/blog/2014/05/07/cloud-foundry%E4%B8%ADcollector%E7%BB%84%E4%BB%B6%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 07 May 2014 10:19:45 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/05/07/cloud-foundry%E4%B8%ADcollector%E7%BB%84%E4%BB%B6%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;在Cloud Foundry中有一个叫collector的组件，该组件的功能是通过消息总线发现在Cloud Foundry中注册过的各个组件的信息，然后通过varz和healthz接口来查询它们的信息并发送到指定的存储位置。&lt;/p&gt;

&lt;p&gt;本文从collector的功能出发，主要讲述以上两个功能的源码实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Foundry中syslog_aggregator的实现分析</title>
      <link>https://Congrool.github.io/blog/2014/05/07/cloud-foundry%E4%B8%ADsyslog-aggregator%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 07 May 2014 10:19:32 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/05/07/cloud-foundry%E4%B8%ADsyslog-aggregator%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;在Cloud Foundry中，用来收集Cloud Foundry各组件日志信息的组件，名为syslog_aggregator。&lt;/p&gt;

&lt;p&gt;syslog_aggregator可以做到方便的收集Cloud Foundry中所有组件的日志信息，并将这些信息进行初步处理，比如说：将不同月份产生的日志，进行分类存储；另外还对同一月份内产生的日志，将其通过不同的日期进行分类。这样的话，当Cloud Foundry平台的开发者，在运营该平台时需要查看Cloud Foundry中某一个组件产生的日志时，可以方便的查找到对应日期的日志。syslog_aggregator除了可以对日志进行分组件，分月份，分日期进行存储外，还提供一些对日志进行打包或剪枝的功能，比如：syslog_aggregator会将一定期限内的日志，进行压缩，以达到节省存储空间的功能；另外syslog_aggregator还会定期对日志进行清除，比如只保存一定期限时间长度的日志，当日志超过该时限，syslog_aggregator会将其清除。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Health_Manager2.0源码分析</title>
      <link>https://Congrool.github.io/blog/2014/04/15/health-manager2-0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 15 Apr 2014 15:14:56 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/04/15/health-manager2-0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;在Cloud Foundry v2版本中，Health_Manager_next已经替代v1版本中的Health_Manager。&lt;/p&gt;

&lt;p&gt;笔者写这篇文档之前，在Github上，Health_Manager_next作为一个单独的项目，存在于Cloud Foundry之下；然而在笔者写这篇文档的时候，Health_Manager_next项目在Cloud Foundry下已经不复存在，然而进入原先的Health_Manager项目，可以发现，Health_Manager项目的项目说明已经成为HealthManager 2.0，因此可见之前的Health_Manager_next项目，也就是HealthManager 2.0如今改名为Health_Manager项目，并覆盖Cloud Foundry v1版本的Health_Manager项目。下文对于该部分的称呼全部使用Health_Manager，而非之前的Health_Manager_next。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[James Bayer]Cloud Foundry和BOSH部分遭受OpenSSL漏洞影响</title>
      <link>https://Congrool.github.io/blog/2014/04/11/james-bayercloud-foundry%E5%92%8Cbosh%E9%83%A8%E5%88%86%E9%81%AD%E5%8F%97openssl%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Fri, 11 Apr 2014 10:49:01 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/04/11/james-bayercloud-foundry%E5%92%8Cbosh%E9%83%A8%E5%88%86%E9%81%AD%E5%8F%97openssl%E6%BC%8F%E6%B4%9E%E5%BD%B1%E5%93%8D/</guid>
      <description>&lt;p&gt;James Bayer &lt;a href=&#34;mailto:jbayer@gopivotal.com&#34;&gt;jbayer@gopivotal.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;greg oehmen (BOSH PM) has put together an excellent explanation on how Cloud Foundry and BOSH stemcells are affected by the OpenSSL heartbleed the CVE.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud_Controller_NG源码阅读记录</title>
      <link>https://Congrool.github.io/blog/2014/04/03/ontroller-ng%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 03 Apr 2014 14:15:12 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2014/04/03/ontroller-ng%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</guid>
      <description>Cloud_Controller_NG就是cloud controller next generation的意思。即Cloud Foundry 平台用来管理控制应用和服务的组件。</description>
    </item>
    
    <item>
      <title>以NATS为主线的CloudFoundry原理</title>
      <link>https://Congrool.github.io/blog/2013/12/02/%E4%BB%A5nats%E4%B8%BA%E4%B8%BB%E7%BA%BF%E7%9A%84cloudfoundry%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 02 Dec 2013 13:04:57 +0000</pubDate>
      
      <guid>https://Congrool.github.io/blog/2013/12/02/%E4%BB%A5nats%E4%B8%BA%E4%B8%BB%E7%BA%BF%E7%9A%84cloudfoundry%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;p&gt;本文将试图以CloudFoundry中的消息组件NATS为主要线索，以在CF中广泛使用的并发和网络编程框架EventMachine为侧重，来串联整个CF主线功能的工作原理，力求能用简单直接的方式描述出较多的架构细节和系统设计。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>https://Congrool.github.io/community/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Congrool.github.io/community/</guid>
      <description>浙大SEL实验室： 浙江大学软件工程实验室（Software Engineering Lab）从属于浙江大学超大规模信息系统研究中心，由丁轶群博士于2011年成立，依托浙江大学计算机理论和应用工程基础研究，扎根于工业界前沿与先进技术领域，致力在云计算平台技术基础上研究关键领域面临的超大规模信息系统问题，通过理论探索和工程实践的有机结合，寻求关键领域信息化发展的突破。</description>
    </item>
    
    <item>
      <title>Contact</title>
      <link>https://Congrool.github.io/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Congrool.github.io/contact/</guid>
      <description>浙大SEL实验室： 浙江大学软件工程实验室（Software Engineering Lab）从属于浙江大学智能计算与软件中心，由丁轶群博士于2011年成立，依托浙江大学计算机理论和应用工程基础研究，扎根于工业界前沿与先进技术领域，致力在云计算平台技术基础上研究关键领域面临的超大规模信息系统问题，通过理论探索和工程实践的有机结合，寻求关键领域信息化发展的突破。</description>
    </item>
    
  </channel>
</rss>