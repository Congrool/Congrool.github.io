<!DOCTYPE html>
<html lang="zh-cn">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Docker背后的容器管理——libcontainer深度解析</title>
  <meta name="author" content="孙健波" />
  
  
  
  
  <meta name="keywords" content="Docker, libcontainer">
  
  
  <meta name="description" content="本文主要介绍了Docker容器管理的方式libcontainer，从libcontainer的使用到源码实现方式。我们深入到容器进程内部，感受到了libcontainer较为全面的设计。总体而言，libcontainer本身主要分为三大块工作内容，一是容器的创建及初始化，二是容器生命周期管理，三则是进程管理，调用方为Docker的execdriver。容器的监控主要通过cgroups的状态统计信息，未来会加入进程追踪等更丰富的功能。另一方面，libcontainer在安全支持方面也为用户尽可能多的提供了支持和选择。遗憾的是，容器安全的配置需要用户对系统安全本身有足够高的理解，user namespace也尚未支持，可见libcontainer依旧有很多工作要完善。但是Docker社区的火热也自然带动了大家对libcontainer的关注，相信在不久的将来，libcontainer就会变得更安全、更易用。">

  <meta name="generator" content="Hugo 0.68.3" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  
  
  
  

  <link href="/css/all.css" rel="stylesheet">
  <link href="/css/bootstrap.min.css" rel="stylesheet">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://Congrool.github.io/index.xml" type="application/rss+xml" title="浙大SEL实验室">

  
  
  
  
  
  
  <meta property="og:updated_time" content="2015-06-03T13:29:26Z">
  
    
    
    <meta property="article:section" content="Docker">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="libcontainer">
    
    
    <meta property="article:published_time" content="2015-06-03T13:29:26Z">
    <meta property="article:modified_time" content="2015-06-03T13:29:26Z">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Docker背后的容器管理——libcontainer深度解析">
  
  <meta name="twitter:description" content="本文主要介绍了Docker容器管理的方式libcontainer，从libcontainer的使用到源码实现方式。我们深入到容器进程内部，感受到了libcontainer较为全面的设计。总体而言，libcontainer本身主要分为三大块工作内容，一是容器的创建及初始化，二是容器生命周期管理，三则是进程管理，调用方为Docker的execdriver。容器的监控主要通过cgroups的状态统计信 …">
  
  
</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar" style="background-color:white;">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/sel.png" alt="Docker背后的容器管理——libcontainer深度解析" class="hidden-xs hidden-sm img-responsive">
                    
                    <span class="sr-only">Docker背后的容器管理——libcontainer深度解析 - </span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only"></span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>

                  <li class="dropdown">
                    
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">社区 <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    
                      <li><a href="https://www.servicemesher.com/">ServiceMesh社区</a></li>
                    
                      <li><a href="">kubeedge社区</a></li>

                      <li><a href="http://www.icsoft.zju.edu.cn/index.php">浙江大学智能计算与软件中心</a></li>
                    
                  </ul>

                  <li class="dropdown">
                    
                    <a href="/archives/">归档</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">关于</a>
                    
                  </li>
                  
                </li>

                
                

                
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>

    
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Docker背后的容器管理——libcontainer深度解析</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                             <a href="#">孙健波</a>
                             | 
                            2015-06-03
                          </p>
                        

                        <div id="post-content">
                          <p>libcontainer 是Docker中用于容器管理的包，它基于Go语言实现，通过管理<code>namespaces</code>、<code>cgroups</code>、<code>capabilities</code>以及文件系统来进行容器控制。你可以使用libcontainer创建容器，并对容器进行生命周期管理。</p>

<blockquote>
<p>容器是一个可管理的执行环境，与主机系统共享内核，可与系统中的其他容器进行隔离。</p>
</blockquote>

<p>在2013年Docker刚发布的时候，它是一款基于LXC的开源容器管理引擎。把LXC复杂的容器创建与使用方式简化为Docker自己的一套命令体系。随着Docker的不断发展，它开始有了更为远大的目标，那就是反向定义容器的实现标准，将底层实现都抽象化到libcontainer的接口。这就意味着，底层容器的实现方式变成了一种可变的方案，无论是使用namespace、cgroups技术抑或是使用systemd等其他方案，只要实现了libcontainer定义的一组接口，Docker都可以运行。这也为Docker实现全面的跨平台带来了可能。</p>

<h2 id="1-libcontainer-特性">1.libcontainer 特性</h2>

<p>目前版本的libcontainer，功能实现上涵盖了包括namespaces使用、cgroups管理、Rootfs的配置启动、默认的Linux capability权限集、以及进程运行的环境变量配置。内核版本最低要求为<code>2.6</code>，最好是<code>3.8</code>，这与内核对namespace的支持有关。 目前除user namespace不完全支持以外，其他五个namespace都是默认开启的，通过<code>clone</code>系统调用进行创建。</p>

<h3 id="1-1-建立文件系统">1.1 建立文件系统</h3>

<p>文件系统方面，容器运行需要<code>rootfs</code>。所有容器中要执行的指令，都需要包含在<code>rootfs</code>（在Docker中指令包含在其上叠加的镜像层也可以执行）所有挂载在容器销毁时都会被卸载，因为mount namespace会在容器销毁时一同消失。为了容器可以正常执行命令，以下文件系统必须在容器运行时挂载到<code>rootfs</code>中。</p>

<p><center>
<img src="https://res.cloudinary.com/rachel725/image/upload/v1605616382/sel/libcontainer1_psvpmn.png" alt="" style="zoom:70%;" />
</center></p>

<p>当容器的文件系统刚挂载完毕时，<code>/dev</code>文件系统会被一系列设备节点所填充，所以<code>rootfs</code>不应该管理<code>/dev</code>文件系统下的设备节点，libcontainer会负责处理并正确启动这些设备。设备及其权限模式如下。</p>

<p><center>
<img src="https://res.cloudinary.com/rachel725/image/upload/v1605616381/sel/libcontainer2_my1m4i.png" alt="" style="zoom:80%;" />
</center></p>

<p>容器支持伪终端<code>TTY</code>，当用户使用时，就会建立<code>/dev/console</code>设备。其他终端支持设备，如<code>/dev/ptmx</code>则是宿主机的<code>/dev/ptmx</code> 链接。容器中指向宿主机 <code>/dev/null</code>的IO也会被重定向到容器内的 <code>/dev/null</code>设备。当<code>/proc</code>挂载完成后，<code>/dev/</code>中与IO相关的链接也会建立，如下表。</p>

<p><center>
<img src="https://res.cloudinary.com/rachel725/image/upload/v1605616381/sel/libcontainer3_izc3zr.png" alt="" style="zoom:100%;" />
</center></p>

<p><code>pivot_root</code> 则用于改变进程的根目录，这样可以有效的将进程控制在我们建立的<code>rootfs</code>中。如果<code>rootfs</code>是基于<code>ramfs</code>的（不支持<code>pivot_root</code>），那么会在<code>mount</code>时使用<code>MS_MOVE</code>标志位加上<code>chroot</code>来顶替。 当文件系统创建完毕后，<code>umask</code>权限被重新设置回<code>0022</code>。</p>

<h3 id="1-2-资源管理">1.2 资源管理</h3>

<p>在<a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation">《Docker背后的内核知识：cgroups资源隔离》</a>一文中已经提到，Docker使用cgroups进行资源管理与限制，包括设备、内存、CPU、输入输出等。 目前除网络外所有内核支持的子系统都被加入到libcontainer的管理中，所以libcontainer使用cgroups原生支持的统计信息作为资源管理的监控展示。 容器中运行的第一个进程<code>init</code>，必须在初始化开始前放置到指定的cgroup目录中，这样就能防止初始化完成后运行的其他用户指令逃逸出cgroups的控制。父子进程的同步则通过管道来完成，在随后的运行时初始化中会进行展开描述。</p>

<h3 id="1-3-可配置的容器安全">1.3 可配置的容器安全</h3>

<p>容器安全一直是被广泛探讨的话题，使用namespace对进程进行隔离是容器安全的基础，遗憾的是，usernamespace由于设计上的复杂性，还没有被libcontainer完全支持。 libcontainer目前可通过配置<a href="http://linux.die.net/man/7/capabilities"><code>capabilities</code></a>、<a href="http://selinuxproject.org/page/Main_Page"><code>SELinux</code></a>、<a href="http://selinuxproject.org/page/Main_Page"><code>apparmor</code></a> 以及<a href="http://en.wikipedia.org/wiki/Seccomp"><code>seccomp</code></a>进行一定的安全防范，目前除<code>seccomp</code>以外都有一份<a href="https://github.com/docker/libcontainer/blob/master/SPEC.md#security">默认的配置项</a>提供给用户作为参考。 在本系列的后续文章中，我们将对容器安全进行更深入的探讨，敬请期待。</p>

<h3 id="1-4-运行时与初始化进程">1.4 运行时与初始化进程</h3>

<p>在容器创建过程中，父进程需要与容器的<code>init</code>进程进行同步通信，通信的方式则通过向容器中传入管道来实现。当<code>init</code>启动时，他会等待管道内传入<code>EOF</code>信息，这就给父进程完成初始化，建立uid/gid映射，并把新进程放进新建的cgroup一定的时间。 在libcontainer中运行的应用（进程），应该是事先静态编译完成的。libcontainer在容器中并不提供任何类似Unix init这样的守护进程，用户提供的参数也是通过<code>exec</code>系统调用提供给用户进程。通常情况下容器中也没有长进程存在。 如果容器打开了伪终端，就会通过<code>dup2</code>把console作为容器的输入输出（STDIN, STDOUT, STDERR）对象。 除此之外，以下4个文件也会在容器运行时自动生成。 * /etc/hosts * /etc/resolv.conf * /etc/hostname * /etc/localtime</p>

<h3 id="1-5-在运行着的容器中执行新进程">1.5 在运行着的容器中执行新进程</h3>

<p>用户也可以在运行着的容器中执行一条新的指令，就是我们熟悉的<code>docker exec</code>功能。同样，执行指令的二进制文件需要包含在容器的<code>rootfs</code>之内。 通过这种方式运行起来的进程会随容器的状态变化，如容器被暂停，进程也随之暂停，恢复也随之恢复。当容器进程不存在时，进程就会被销毁，重启也不会恢复。</p>

<h3 id="1-6-容器热迁移-checkpoint-restore">1.6 容器热迁移（Checkpoint &amp; Restore）</h3>

<p>目前libcontainer已经集成了<a href="http://criu.org/Main_Page">CRIU</a>作为容器检查点保存与恢复（通常也称为热迁移）的解决方案，应该在不久之后就会被Docker使用。也就是说，通过libcontainer你已经可以把一个正在运行的进程状态保存到磁盘上，然后在本地或其他机器中重新恢复当前的运行状态。这个功能主要带来如下几个好处。</p>

<ul>
<li>服务器需要维护（如系统升级、重启等）时，通过热迁移技术把容器转移到别的服务器继续运行，应用服务信息不会丢失。</li>
<li>对于初始化时间极长的应用程序来说，容器热迁移可以加快启动时间，当应用启动完成后就保存它的检查点状态，下次要重启时直接通过检查点启动即可。</li>
<li>在高性能计算的场景中，容器热迁移可以保证运行了许多天的计算结果不会丢失，只要周期性的进行检查点快照保存就可以了。</li>
</ul>

<p>要使用这个功能，需要保证机器上已经安装了1.5.2或更高版本的<code>criu</code>工具。不同Linux发行版都有<code>criu</code>的安装包，你也可以在CRIU官网上找到从<a href="http://criu.org/Installation">源码安装</a>的方法。我们将会在<code>nsinit</code>的使用中介绍容器热迁移的使用方法。 CRIU（Checkpoint/Restore In Userspace）由OpenVZ项目于2005年发起，因为其涉及的内核系统繁多、代码多达数万行，其复杂性与向后兼容性都阻碍着它进入内核主线，几经周折之后决定在用户空间实现，并在2012年被Linus加并入内核主线，其后得以快速发展。 你可以在CRIU官网查看<a href="http://criu.org/Checkpoint/Restore">其原理</a>，简单描述起来可以分为两部分，一是检查点的保存，其中分为3步。</p>

<ol>
<li>收集进程与其子进程构成的树，并冻结所有进程。</li>
<li>收集任务（包括进程和线程）使用的所有资源，并保存。</li>
<li>清理我们收集资源的相关寄生代码，并与进程分离。</li>
</ol>

<p>第二部分自然是恢复，分为4步。</p>

<ol>
<li>读取快照文件并解析出共享的资源，对多个进程共享的资源优先恢复，其他资源则随后需要时恢复。</li>
<li>使用fork恢复整个进程树，注意此时并不恢复线程，在第4步恢复。</li>
<li>恢复所有基础任务（包括进程和线程）资源，除了内存映射、计时器、证书和线程。这一步主要打开文件、准备namespace、创建socket连接等。</li>
<li>恢复进程运行的上下文环境，恢复剩下的其他资源，继续运行进程。</li>
</ol>

<p>至此，libcontainer的基本特性已经预览完毕，下面我们将从使用开始，一步步深入libcontainer的原理。</p>

<h2 id="2-nsinit-与libcontainer的使用">2. <code>nsinit</code>与libcontainer的使用</h2>

<p>俗话说，了解一个工具最好的入门方式就是去使用它，<code>nsinit</code>就是一个为了方便不通过Docker就可以直接使用<code>libcontainer</code>而开发的命令行工具。它可以用于启动一个容器或者在已有的容器中执行命令。使用<code>nsinit</code>需要有 rootfs 以及相应的配置文件。</p>

<h3 id="2-1-nsinit-的构建">2.1 <code>nsinit</code>的构建</h3>

<p>使用<code>nsinit</code>需要<code>rootfs</code>，最简单最常用的是使用<a href="https://github.com/jpetazzo/docker-busybox"><code>Docker busybox</code></a>，相关配置文件则可以参考<a href="https://github.com/docker/libcontainer/tree/master/sample_configs"><code>sample_configs</code></a>目录，主要配置的参数及其作用将在<strong>配置参数</strong>一节中介绍。拷贝一份命名为<code>container.json</code>文件到你<code>rootfs</code>所在目录中，这份文件就包含了你对容器做的特定配置，包括运行环境、网络以及不同的权限。这份配置对容器中的所有进程都会产生效果。 具体的构建步骤在官方的<a href="https://github.com/docker/libcontainer/blob/master/nsinit/README.md"><code>README</code></a>文档中已经给出，在此为了节省篇幅不再赘述。 最终编译完成后生成<code>nsinit</code>二进制文件，将这个指令加入到系统的环境变量，在busybox目录下执行如下命令，即可使用，需要<strong>root</strong>权限。 <code>nsinit exec --tty --config container.json /bin/bash</code> 执行完成后会生成一个以容器ID命名的文件夹，上述命令没有指定容器ID，默认名为&rdquo;nsinit&rdquo;，在“nsinit”文件夹下会生成一个<code>state.json</code>文件，表示容器的状态，其中的内容与配置参数中的内容类似，展示容器的状态。</p>

<h3 id="2-2-nsinit-的使用">2.2 <code>nsinit</code>的使用</h3>

<p>目前<code>nsinit</code>定义了9个指令，使用<code>nsinit -h</code>就可以看到，对于每个单独的指令使用<code>--help</code>就能获得更详细的使用参数，如<code>nsinit config --help</code>。 <code>nsinit</code>这个命令行工具是通过<a href="https://github.com/codegangsta/cli"><code>cli.go</code></a>实现的，<code>cli.go</code>封装了命令行工具需要做的一些细节，包括参数解析、命令执行函数构建等等，这就使得<code>nsinit</code>本身的代码非常简洁明了。具体的命令功能如下。</p>

<ul>
<li><strong>config</strong>：使用内置的默认参数加上执行命令时用户添加的部分参数，生成一份容器可用的标准配置文件。</li>
<li><strong>exec</strong>：启动容器并执行命令。除了一些共有的参数外，还有如下一些独有的参数。

<ul>
<li><strong>--tty,-t</strong>：为容器分配一个终端显示输出内容。</li>
<li><strong>--config</strong>：使用配置文件，后跟文件路径。</li>
<li><strong>--id</strong>：指定容器ID，默认为<code>nsinit</code>。</li>
<li><strong>--user,-u</strong>：指定用户，默认为“root”.</li>
<li><strong>--cwd</strong>：指定当前工作目录。</li>
<li><strong>--env</strong>：为进程设置环境变量。</li>
</ul></li>
<li><strong>init</strong>：这是一个内置的参数，用户并不能直接使用。这个命令是在容器内部执行，为容器进行namespace初始化，并在完成初始化后执行用户指令。所以在代码中，运行<code>nsinit exec</code>后，传入到容器中运行的实际上是<code>nsinit init</code>，把用户指令作为配置项传入。</li>
<li><strong>oom</strong>：展示容器的内存超限通知。</li>
<li><strong>pause</strong>/<strong>unpause</strong>：暂停/恢复容器中的进程。</li>
<li><strong>stats</strong>：显示容器中的统计信息，主要包括cgroup和网络。</li>
<li><strong>state</strong>：展示容器状态，就是读取<code>state.json</code>文件。</li>

<li><p><strong>checkpoint</strong>：保存容器的检查点快照并结束容器进程。需要填<code>--image-path</code>参数，后面是检查点保存的快照文件路径。完整的命令示例如下。 <code>nsinit checkpoint --image-path=/tmp/criu</code></p></li>

<li><p><strong>restore</strong>：从容器检查点快照恢复容器进程的运行。参数同上。</p></li>
</ul>

<p>总结起来，<code>nsinit</code>与Docker execdriver进行的工作基本相同，所以在Docker的源码中并不会涉及到<code>nsinit</code>包的调用，但是<code>nsinit</code>为libcontainer自身的调试和使用带来了极大的便利。</p>

<h2 id="3-配置参数解析">3. 配置参数解析</h2>

<ul>
<li><code>no_pivot_root</code> ：这个参数表示用<code>rootfs</code>作为文件系统挂载点，不单独设置<code>pivot_root</code>。</li>
<li><code>parent_death_signal</code>： 这个参数表示当容器父进程销毁时发送给容器进程的信号。</li>
<li><code>pivot_dir</code>：在容器<code>root</code>目录中指定一个目录作为容器文件系统挂载点目录。</li>
<li><code>rootfs</code>：容器根目录位置。</li>
<li><code>readonlyfs</code>：设定容器根目录为只读。</li>
<li><code>mounts</code>：设定额外的挂载，填充的信息包括原路径，容器内目的路径，文件系统类型，挂载标识位，挂载的数据大小和权限，最后设定共享挂载还是非共享挂载（独立于<code>mount_label</code>的设定起作用）。</li>
<li><code>devices</code>：设定在容器启动时要创建的设备，填充的信息包括设备类型、容器内设备路径、设备块号（major，minor）、cgroup文件权限、用户编号、用户组编号。</li>
<li><code>mount_label</code>：设定共享挂载还是非共享挂载。</li>
<li><code>hostname</code>：设定主机名。</li>
<li><code>namespaces</code>：设定要加入的namespace，每个不同种类的namespace都可以指定，默认与父进程在同一个namespace中。</li>
<li><code>capabilities</code>：设定在容器内的进程拥有的<code>capabilities</code>权限，所有没加入此配置项的<code>capabilities</code>会被移除，即容器内进程失去该权限。</li>
<li><code>networks</code>：初始化容器的网络配置，包括类型（loopback、veth）、名称、网桥、物理地址、IPV4地址及网关、IPV6地址及网关、Mtu大小、传输缓冲长度<code>txqueuelen</code>、Hairpin Mode设置以及宿主机设备名称。</li>
<li><code>routes</code>：配置路由表。</li>
<li><code>cgroups</code>：配置cgroups资源限制参数，使用的参数不多，主要包括允许的设备列表、内存、交换区用量、CPU用量、块设备访问优先级、应用启停等。</li>
<li><code>apparmor_profile</code>：配置用于SELinux的apparmor文件。</li>
<li><code>process_label</code>：同样用于selinux的配置。</li>
<li><code>rlimits</code>：最大文件打开数量，默认与父进程相同。</li>
<li><code>additional_groups</code>：设定<code>gid</code>，添加同一用户下的其他组。</li>
<li><code>uid_mappings</code>：用于User namespace的uid映射。</li>
<li><code>gid_mappings</code>：用户User namespace的gid映射。</li>
<li><code>readonly_paths</code>：在容器内设定只读部分的文件路径。</li>
<li><code>MaskPaths</code>：配置不使用的设备，通过绑定<code>/dev/null</code>进行路径掩盖。</li>
</ul>

<h2 id="4-libcontainer实现原理">4. libcontainer实现原理</h2>

<p>在Docker中，对容器管理的模块为<code>execdriver</code>，目前Docker支持的容器管理方式有两种，一种就是最初支持的LXC方式，另一种称为<code>native</code>，即使用libcontainer进行容器管理。在孙宏亮的<a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part3">《Docker源码分析系列》</a>中，Docker Deamon启动过程中就会对execdriver进行初始化，会根据驱动的名称选择使用的容器管理方式。 虽然在<code>execdriver</code>中只有LXC和native两种选择，但是native（即<code>libcontainer</code>）通过接口的方式定义了一系列容器管理的操作，包括处理容器的创建（Factory）、容器生命周期管理（Container）、进程生命周期管理（Process）等一系列接口，相信如果Docker的热潮一直像如今这般汹涌，那么不久的将来，Docker必将实现其全平台通用的宏伟蓝图。本节也将从libcontainer的这些抽象对象开始讲解，与你一同解开Docker容器管理之谜。在介绍抽象对象的具体实现过程中会与Docker execdriver联系起来，让你充分了解整个过程。</p>

<h3 id="4-1-factory-对象">4.1 Factory 对象</h3>

<p>Factory对象为容器创建和初始化工作提供了一组抽象接口，目前已经具体实现的是Linux系统上的Factory对象。Factory抽象对象包含如下四个方法，我们将主要描述这四个方法的工作过程，涉及到具体实现方法则以LinuxFactory为例进行讲解。</p>

<ol>
<li><strong>Create()</strong>：通过一个<code>id</code>和一份配置参数创建容器，返回一个运行的进程。容器的<code>id</code>由字母、数字和下划线构成，长度范围为1~1024。容器ID为每个容器独有，不能冲突。创建的最终返回一个Container类，包含这个<code>id</code>、状态目录（在root目录下创建的以<code>id</code>命名的文件夹，存<code>state.json</code>容器状态文件）、容器配置参数、初始化路径和参数，以及管理cgroup的方式（包含直接通过文件操作管理和systemd管理两个选择，默认选cgroup文件系统管理）。</li>
<li><strong>Load()</strong>：当创建的<code>id</code>已经存在时，即已经<code>Create</code>过，存在<code>id</code>文件目录，就会从<code>id</code>目录下直接读取<code>state.json</code>来载入容器。其中的参数在配置参数部分有详细解释。</li>
<li><strong>Type()</strong>：返回容器管理的类型，目前可能返回的有libcontainer和lxc，为未来支持更多容器接口做准备。</li>
<li><strong>StartInitialization()</strong>：容器内初始化函数。

<ul>
<li>这部分代码是在容器内部执行的，当容器创建时，如果<code>New</code>不加任何参数，默认在容器进程中运行的第一条命令就是<code>nsinit init</code>。在<code>execdriver</code>的初始化中，会向<code>reexec</code>注册初始化器，命名为<code>native</code>，然后在创建libcontainer以后把<code>native</code>作为执行参数传递到容器中执行，这个初始化器创建的libcontainer就是没有参数的。</li>
<li>传入的参数是一个管道文件描述符，为了保证在初始化过程中，父子进程间状态同步和配置信息传递而建立。</li>
<li>不管是纯粹新建的容器还是已经创建的容器执行新的命令，都是从这个入口做初始化。</li>
<li>第一步，通过管道获取配置信息。</li>
<li>第二步，从配置信息中获取环境变量并设置为容器内环境变量。</li>
<li>若是已经存在的容器执行新命令，则只需要配置cgroup、namespace的Capabilities以及AppArmor等信息，最后执行命令。</li>
<li>若是纯粹新建的容器，则还需要初始化网络、路由、namespace、主机名、配置只读路径等等，最后执行命令。</li>
</ul></li>
</ol>

<p>至此，容器就已经创建和初始化完毕了。</p>

<h3 id="4-2-container-对象">4.2 Container 对象</h3>

<p>Container对象主要包含了容器配置、控制、状态显示等功能，是对不同平台容器功能的抽象。目前已经具体实现的是Linux平台下的Container对象。每一个Container进程内部都是线程安全的。因为Container有可能被外部的进程销毁，所以每个方法都会对容器是否存在进行检测。</p>

<ol>
<li><strong>ID()</strong>：显示Container的ID，在Factor对象中已经说过，ID很重要，具有唯一性。</li>
<li><strong>Status()</strong>：返回容器内进程是运行状态还是停止状态。通过执行“SIG=0”的KILL命令对进程是否存在进行检测。</li>
<li><strong>State()</strong>：返回容器的状态，包括容器ID、配置信息、初始进程ID、进程启动时间、cgroup文件路径、namespace路径。通过调用<code>Status()</code>判断进程是否存在。</li>
<li><strong>Config()</strong>：返回容器的配置信息，可在“配置参数解析”部分查看有哪些方面的配置信息。</li>
<li><strong>Processes()</strong>：返回cgroup文件<code>cgroup.procs</code>中的值，在<a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation">Docker背后的内核知识：cgroups资源限制</a>部分的讲解中我们已经提过，<code>cgroup.procs</code>文件会罗列所有在该cgroup中的线程组ID（即若有线程创建了子线程，则子线程的PID不包含在内）。由于容器不断在运行，所以返回的结果并不能保证完全存活，除非容器处于“PAUSED”状态。</li>
<li><strong>Stats()</strong>：返回容器的统计信息，包括容器的cgroups中的统计以及网卡设备的统计信息。Cgroups中主要统计了cpu、memory和blkio这三个子系统的统计内容，具体了解可以通过阅读<a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation">“cgroups资源限制”</a>部分对于这三个子系统统计内容的介绍来了解。网卡设备的统计则通过读取系统中，网络网卡文件的统计信息文件<code>/sys/class/net/&lt;EthInterface&gt;/statistics</code>来实现。</li>
<li><strong>Set()</strong>：设置容器cgroup各子系统的文件路径。因为cgroups的配置是进程运行时也会生效的，所以我们可以通过这个方法在容器运行时改变cgroups文件从而改变资源分配。</li>
<li><strong>Start()</strong>：构建ParentProcess对象，用于处理启动容器进程的所有初始化工作，并作为父进程与新创建的子进程（容器）进行初始化通信。传入的Process对象可以帮助我们追踪进程的生命周期，Process对象将在后文详细介绍。

<ul>
<li>启动的过程首先会调用<code>Status()</code>方法的具体实现得知进程是否存活。</li>
<li>创建一个<strong>管道</strong>（详见Docker初始化通信——管道）为后期父子进程通信做准备。</li>
<li>配置子进程<code>cmd</code>命令模板，配置参数的值就是从<code>factory.Create()</code>传入进来的，包括命令执行的工作目录、命令参数、输入输出、根目录、子进程管道以及<code>KILL</code>信号的值。</li>
<li>根据容器进程是否存在确定是在已有容器中执行命令还是创建新的容器执行命令。若存在，则把配置的命令构建成一个<code>exec.Cmd</code>对象、cgroup路径、父子进程管道及配置保留到ParentProcess对象中；若不存在，则创建容器进程及相应namespace，目前对user namespace有了一定的支持，若配置时加入user namespace，会针对配置项进行映射，默认映射到宿主机的root用户，最后同样构建出相应的配置内容保留到ParentProcess对象中。通过在<code>cmd.Env</code>写入环境变量<code>_libcontainer_INITTYPE</code>来告诉容器进程采用的哪种方式启动。</li>
<li>执行ParentProcess中构建的<code>exec.Cmd</code>内容，即执行<code>ParentProcess.start()</code>，具体的执行过程在Process部分介绍。</li>
<li>最后如果是新建的容器进程，还会执行状态更新函数，把<code>state.json</code>的内容刷新。</li>
</ul></li>
<li><strong>Destroy()</strong>：首先使用cgroup的freezer子系统暂停所有运行的进程，然后给所有进程发送<code>SIGKIL</code>信号（如果没有使用<code>pid namespace</code>就不对进程处理）。最后把cgroup及其子系统卸载，删除cgroup文件夹。</li>
<li><strong>Pause()</strong>：使用cgroup的freezer子系统暂停所有运行的进程。</li>
<li><strong>Resume()</strong>：使用cgroup的freezer子系统恢复所有运行的进程。</li>
<li><strong>NotifyOOM()</strong>：为容器内存使用超界提供只读的通道，通过向<code>cgroup.event_control</code>写入<code>eventfd</code>（用作线程间通信的消息队列）和<code>cgroup.oom_control</code>（用于决定内存使用超限后的处理方式）来实现。</li>
<li><strong>Checkpoint()</strong>：保存容器进程检查点快照，为容器热迁移做准备。通过使用CRIU的<a href="http://lists.openvz.org/pipermail/criu/2015-March/019400.html">SWRK模式</a>来实现，这种模式是CRIU另外两种模式CLI和RPC的结合体，允许用户需要的时候像使用命令行工具一样运行CRIU，并接受用户远程调用的请求，即传入的热迁移检查点保存请求，传入文件形式以Google的protobuf协议保存。</li>
<li><strong>Restore()</strong>：恢复检查点快照并运行，完成容器热迁移。同样通过CRIU的SWRK模式实现，恢复的时候可以传入配置文件设置恢复挂载点、网络等配置信息。</li>
</ol>

<p>至此，Container对象中的所有函数及相关功能都已经介绍完毕，包含了容器生命周期的全部过程。</p>

<h4 id="tips-docker初始化通信-管道">TIPs： Docker初始化通信——管道</h4>

<p>libcontainer创建容器进程时需要做初始化工作，此时就涉及到使用了namespace隔离后的两个进程间的通信。我们把负责创建容器的进程称为父进程，容器进程称为子进程。父进程<code>clone</code>出子进程以后，依旧是共享内存的。但是如何让子进程知道内存中写入了新数据依旧是一个问题，一般有四种方法。</p>

<ul>
<li>发送信号通知（signal）</li>
<li>对内存轮询访问（poll memory）</li>
<li>sockets通信（sockets）</li>
<li>文件和文件描述符（files and file-descriptors）</li>
</ul>

<p>对于Signal而言，本身包含的信息有限，需要额外记录，namespace带来的上下文变化使其不易理解，并不是最佳选择。显然通过轮询内存的方式来沟通是一个非常低效的做法。另外，因为Docker会加入network namespace，实际上初始时网络栈也是完全隔离的，所以socket方式并不可行。 Docker最终选择的方式就是打开的可读可写文件描述符——管道。 Linux中，通过<code>pipe(int fd[2])</code>系统调用就可以创建管道，参数是一个包含两个整型的数组。调用完成后，在<code>fd[1]</code>端写入的数据，就可以从<code>fd[0]</code>端读取。</p>

<p>// 需要加入头文件:
#include // 全局变量:
int fd[2];
// 在父进程中进行初始化:
pipe(fd);
// 关闭管道文件描述符
close(checkpoint[1]);</p>

<p>调用<code>pipe</code>函数后，创建的子进程会内嵌这个打开的文件描述符，对<code>fd[1]</code>写入数据后可以在<code>fd[0]</code>端读取。通过管道，父子进程之间就可以通信。通信完毕的奥秘就在于<code>EOF</code>信号的传递。大家都知道，当打开的文件描述符都关闭时，才能读到<code>EOF</code>信号，所以<code>libcontainer</code>中父进程先关闭自己这一端的管道，然后等待子进程关闭另一端的管道文件描述符，传来<code>EOF</code>表示子进程已经完成了初始化的过程。</p>

<h3 id="4-3-process-对象">4.3 Process 对象</h3>

<p>Process 主要分为两类，一类在源码中就叫<code>Process</code>，用于容器内进程的配置和IO的管理；另一类在源码中叫<code>ParentProcess</code>，负责处理容器启动工作，与Container对象直接进行接触，启动完成后作为<code>Process</code>的一部分，执行等待、发信号、获得<code>pid</code>等管理工作。 <strong>ParentProcess对象</strong>，主要包含以下六个函数，而根据”需要新建容器”和“在已经存在的容器中执行”的不同方式，具体的实现也有所不同。</p>

<ul>
<li><p><strong>已有容器中执行命令</strong></p>

<ol>
<li><strong>pid()</strong>： 启动容器进程后通过管道从容器进程中获得，因为容器已经存在，与Ｄocker Ｄeamon在不同的pid namespace中，从进程所在的namespace获得的进程号才有意义。</li>
<li><strong>start()</strong>： 初始化容器中的执行进程。在已有容器中执行命令一般由<code>docker exec</code>调用，在execdriver包中，执行<code>exec</code>时会引入<code>nsenter</code>包，从而调用其中的C语言代码，执行<code>nsexec()</code>函数，该函数会读取配置文件，使用<code>setns()</code>加入到相应的namespace，然后通过<code>clone()</code>在该namespace中生成一个子进程，并把子进程通过管道传递出去，使用<code>setns()</code>以后并没有进入pid namespace，所以还需要通过加上<code>clone()</code>系统调用。
<br /></li>
</ol>

<ul>
<li>开始执行进程，首先会运行<code>C</code>代码，通过管道获得进程pid，最后等待<code>C</code>代码执行完毕。</li>
<li>通过获得的pid把cmd中的Process替换成新生成的子进程。</li>
<li>把子进程加入cgroup中。</li>
<li>通过管道传配置文件给子进程。</li>
<li>等待初始化完成或出错返回，结束。</li>
</ul></li>

<li><p><strong>新建容器执行命令</strong></p>

<ol>
<li><strong>pid()</strong>：启动容器进程后通过<code>exec.Cmd</code>自带的<code>pid()</code>函数即可获得。</li>
<li><strong>start()</strong>：初始化及执行容器命令。
<br /></li>
</ol>

<ul>
<li>开始运行进程。</li>
<li>把进程pid加入到cgroup中管理。</li>
<li>初始化容器网络。（本部分内容丰富，将从本系列的后续文章中深入讲解）</li>
<li>通过管道发送配置文件给子进程。</li>
<li>等待初始化完成或出错返回，结束。</li>
</ul></li>

<li><p><strong>实现方式类似的一些函数</strong></p>

<ul>
<li>**terminate() **：发送<code>SIGKILL</code>信号结束进程。</li>
<li>**startTime() **：获取进程的启动时间。</li>
<li><strong>signal()</strong>：发送信号给进程。</li>
<li><strong>wait()</strong>：等待程序执行结束，返回结束的程序状态。</li>
</ul></li>
</ul>

<p><strong>Process对象</strong>，主要描述了容器内进程的配置以及IO。包括参数<code>Args</code>，环境变量<code>Env</code>，用户<code>User</code>（由于uid、gid映射），工作目录<code>Cwd</code>，标准输入输出及错误输入，控制终端路径<code>consolePath</code>，容器权限<code>Capabilities</code>以及上述提到的ParentProcess对象<code>ops</code>（拥有上面的一些操作函数，可以直接管理进程）。</p>

<h2 id="5-总结">5. 总结</h2>

<p>本文主要介绍了Docker容器管理的方式libcontainer，从libcontainer的使用到源码实现方式。我们深入到容器进程内部，感受到了libcontainer较为全面的设计。总体而言，libcontainer本身主要分为三大块工作内容，一是容器的创建及初始化，二是容器生命周期管理，三则是进程管理，调用方为Docker的<code>execdriver</code>。容器的监控主要通过cgroups的状态统计信息，未来会加入进程追踪等更丰富的功能。另一方面，libcontainer在安全支持方面也为用户尽可能多的提供了支持和选择。遗憾的是，容器安全的配置需要用户对系统安全本身有足够高的理解，user namespace也尚未支持，可见libcontainer依旧有很多工作要完善。但是Docker社区的火热也自然带动了大家对libcontainer的关注，相信在不久的将来，libcontainer就会变得更安全、更易用。</p>
                        </div>
                        
                        
                        
                        
                        
                        

                        
                        <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                        <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
                        <script type="text/javascript" src="/assets/js/md5.min.js"></script>
                        <div id="gitalk-container"></div>     
                        <script type="text/javascript">
                            var gitalk = new Gitalk({
                              clientID: '835183d2dcbd1167ac28', 
                            
                              clientSecret: 'd873919fac3cc76921ee0800172c2279bc612f8d', 
                            
                              repo: 'Sel-Website-talk',
                              owner: 'Peeknut',
                              admin: ['Peeknut','Rachel-Shao'],
                              id: location.href.split("/").pop().substring(0, 49),      
                              distractionFreeMode: false  
                            })
                            gitalk.render('gitalk-container')
                        </script> 
                        

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">搜索栏</h3>
      
    </div>

    <div class="panel-body">
        
        <div class="search" id="search">
            <div class="input-group">
                <input type="text" name="q" class="form-control" placeholder="请输入文章标题或摘要..." id="search-key">
                <input type="hidden" name="sitesearch" value="https://Congrool.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main" onclick="search()"><i class="fas fa-search"></i></button>
                </span>
            </div>
            <h1 id="search-tip" style="color: red;text-align: center;display: none;font-size: medium;">搜索中，请稍后 ...</h1>
        </div>
        <script type="text/javascript">
            
            window.onload = function() {
                      document.onkeydown = function(ev) {
                        var event = ev || event
                        if (event.keyCode == 13) {
                          search()
                        }
                      }
                    }
            
            function search() {
                    
                      key = document.getElementById("search-key").value;
                      if (key === "") {
                        
                        return;
                      }
                      key = key.toLowerCase();
                      document.getElementById("search-key").value = "";
                  
                      
                      document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
                      document.getElementById("search-tip").style.display = "block";
                  
                      
                      var el = document.getElementById('blog-listing-medium');
                      if (el == null) {
                        el = document.getElementById("blog-post")
                      }
                      var childs = el.childNodes;
                      for (var i = childs.length - 1; i >= 0; i--) {
                        el.removeChild(childs[i]);
                      }
                  
                      
                      xmltext = new XMLHttpRequest;
                      xmltext.open("GET", "/index.xml", false);
                      xmltext.send();
                      resp = xmltext.responseXML;
                      
                      items = resp.getElementsByTagName("item");
                      
                      var i = 0;
                      haveResult = false;
                      while (i < items.length) {
                        txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML
                        txt = txt.toLowerCase();
                        if (txt.indexOf(key) > -1) {
                          haveResult = true;
                          title = items[i].getElementsByTagName("title")[0].innerHTML;
                          link = items[i].getElementsByTagName("link")[0].innerHTML;
                          time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                          mark = items[i].getElementsByTagName("description")[0].innerHTML;
                          time = time.slice(0, -5);
                          addItem(title, link, time, mark)
                        }
                        i++;
                      }
                      if (!haveResult) {
                        document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
                        document.getElementById("search-tip").style.display = "block";
                      }

                      
                      var el = document.getElementById("blog-head");
                      el.innerHTML="Blogs"
                    }
                  
                    
                    function addItem(title, link, time, mark) {
                      document.getElementById("search-tip").style.display = "none";
                      tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
                        "<header class=\"post-header\">" +
                        "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
                        "<div class=\"post-meta\">" +
                        " <span class=\"post-time\">" + time + "</span>" +
                        "</div>" +
                        " </header>" +
                        "<div class=\"post-content\">" +
                        "<div class=\"post-summary\">" + mark + "</div>" +
                        "<div class=\"read-more\">" +
                        "<a href=" + link + " class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
                        "</div>" +
                        " </div>" +
                        "</article>"
                      div = document.createElement("div")
                      div.innerHTML = tmpl;
                      var el = document.getElementById('blog-listing-medium');
                      if (el == null) {
                        el = document.getElementById("blog-post")
                      }
                      el.appendChild(div)
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    

        </script>
        
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">归档栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/bosh">bosh (1)</a>
            </li>
            
            <li>
                <a href="/categories/cloud_controller_ng">cloud_controller_ng (1)</a>
            </li>
            
            <li>
                <a href="/categories/cloudfoundry">cloudfoundry (15)</a>
            </li>
            
            <li>
                <a href="/categories/containerd">containerd (1)</a>
            </li>
            
            <li>
                <a href="/categories/docker">docker (19)</a>
            </li>
            
            <li>
                <a href="/categories/etcd">etcd (1)</a>
            </li>
            
            <li>
                <a href="/categories/haproxy">haproxy (1)</a>
            </li>
            
            <li>
                <a href="/categories/healthmanager">healthmanager (1)</a>
            </li>
            
            <li>
                <a href="/categories/karmada">karmada (4)</a>
            </li>
            
            <li>
                <a href="/categories/kubeedge">kubeedge (5)</a>
            </li>
            
            <li>
                <a href="/categories/kubernetes">kubernetes (14)</a>
            </li>
            
            <li>
                <a href="/categories/network">network (1)</a>
            </li>
            
            <li>
                <a href="/categories/openyurt">openyurt (2)</a>
            </li>
            
            <li>
                <a href="/categories/service-mesh">service-mesh (4)</a>
            </li>
            
        </ul>
    </div>

</div>








<div class="panel sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">标签栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            
            <li>
                <a href="/tags/agent"><i class="fas fa-tags"></i> agent</a>
            </li>
            
            <li>
                <a href="/tags/apiserver"><i class="fas fa-tags"></i> apiserver</a>
            </li>
            
            <li>
                <a href="/tags/books"><i class="fas fa-tags"></i> books</a>
            </li>
            
            <li>
                <a href="/tags/bosh"><i class="fas fa-tags"></i> bosh</a>
            </li>
            
            <li>
                <a href="/tags/ccng"><i class="fas fa-tags"></i> ccng</a>
            </li>
            
            <li>
                <a href="/tags/cf-release"><i class="fas fa-tags"></i> cf-release</a>
            </li>
            
            <li>
                <a href="/tags/cgroups"><i class="fas fa-tags"></i> cgroups</a>
            </li>
            
            <li>
                <a href="/tags/cloudfoundry"><i class="fas fa-tags"></i> cloudfoundry</a>
            </li>
            
            <li>
                <a href="/tags/cloudnative"><i class="fas fa-tags"></i> cloudnative</a>
            </li>
            
            <li>
                <a href="/tags/collector"><i class="fas fa-tags"></i> collector</a>
            </li>
            
            <li>
                <a href="/tags/containerd"><i class="fas fa-tags"></i> containerd</a>
            </li>
            
            <li>
                <a href="/tags/cri"><i class="fas fa-tags"></i> cri</a>
            </li>
            
            <li>
                <a href="/tags/dea"><i class="fas fa-tags"></i> dea</a>
            </li>
            
            <li>
                <a href="/tags/docker"><i class="fas fa-tags"></i> docker</a>
            </li>
            
            <li>
                <a href="/tags/docker-network"><i class="fas fa-tags"></i> docker-network</a>
            </li>
            
            <li>
                <a href="/tags/edgecomputing"><i class="fas fa-tags"></i> edgecomputing</a>
            </li>
            
            <li>
                <a href="/tags/etcd"><i class="fas fa-tags"></i> etcd</a>
            </li>
            
            <li>
                <a href="/tags/gorouter"><i class="fas fa-tags"></i> gorouter</a>
            </li>
            
            <li>
                <a href="/tags/haproxy"><i class="fas fa-tags"></i> haproxy</a>
            </li>
            
            <li>
                <a href="/tags/healthmanager"><i class="fas fa-tags"></i> healthmanager</a>
            </li>
            
            <li>
                <a href="/tags/istio"><i class="fas fa-tags"></i> istio</a>
            </li>
            
            <li>
                <a href="/tags/karmada"><i class="fas fa-tags"></i> karmada</a>
            </li>
            
            <li>
                <a href="/tags/kubeedge"><i class="fas fa-tags"></i> kubeedge</a>
            </li>
            
            <li>
                <a href="/tags/kubelet"><i class="fas fa-tags"></i> kubelet</a>
            </li>
            
            <li>
                <a href="/tags/kubernetes"><i class="fas fa-tags"></i> kubernetes</a>
            </li>
            
            <li>
                <a href="/tags/libcontainer"><i class="fas fa-tags"></i> libcontainer</a>
            </li>
            
            <li>
                <a href="/tags/micro-service"><i class="fas fa-tags"></i> micro-service</a>
            </li>
            
            <li>
                <a href="/tags/namespace"><i class="fas fa-tags"></i> namespace</a>
            </li>
            
            <li>
                <a href="/tags/nats"><i class="fas fa-tags"></i> nats</a>
            </li>
            
            <li>
                <a href="/tags/news"><i class="fas fa-tags"></i> news</a>
            </li>
            
            <li>
                <a href="/tags/openyurt"><i class="fas fa-tags"></i> openyurt</a>
            </li>
            
            <li>
                <a href="/tags/pipework"><i class="fas fa-tags"></i> pipework</a>
            </li>
            
            <li>
                <a href="/tags/pouch"><i class="fas fa-tags"></i> pouch</a>
            </li>
            
            <li>
                <a href="/tags/runc"><i class="fas fa-tags"></i> runc</a>
            </li>
            
            <li>
                <a href="/tags/runtime"><i class="fas fa-tags"></i> runtime</a>
            </li>
            
            <li>
                <a href="/tags/security"><i class="fas fa-tags"></i> security</a>
            </li>
            
            <li>
                <a href="/tags/serverless"><i class="fas fa-tags"></i> serverless</a>
            </li>
            
            <li>
                <a href="/tags/service-mesh"><i class="fas fa-tags"></i> service-mesh</a>
            </li>
            
            <li>
                <a href="/tags/syslog_aggregator"><i class="fas fa-tags"></i> syslog_aggregator</a>
            </li>
            
        </ul>
    </div>

</div>






                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4></h4>

            <p><strong>关于我们：<strong> <p>浙大SEL实验室</p><p>地址：杭州市浙大路38号曹光彪西楼405室</p><p><strong></strong>
            <a href="/contact" class="btn btn-small btn-template-main" >跳转到关于</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>
            

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Congrool.github.io/blog/2022/08/26/%E5%9F%BA%E4%BA%8Ekubeedge%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
                          
                            <img src="/img/blogs/27/overview.png" class="img-responsive" alt="基于KubeEdge的边缘节点分组管理设计与实现">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Congrool.github.io/blog/2022/08/26/%E5%9F%BA%E4%BA%8Ekubeedge%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">基于KubeEdge的边缘节点分组管理设计与实现</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Congrool.github.io/blog/2021/09/22/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6karmada-scheduler%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/">
                          
                            <img src="/img/blogs/20/karmada-scheduler.png" class="img-responsive" alt="多云环境下的资源调度：karmada scheduler的框架和实现">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Congrool.github.io/blog/2021/09/22/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6karmada-scheduler%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/">多云环境下的资源调度：karmada scheduler的框架和实现</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Congrool.github.io/blog/2021/09/16/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%88%90%E5%91%98%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEkarmada%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/">
                          
                            <img src="/img/blogs/19/karmada-arch.jpg" class="img-responsive" alt="多云环境下的成员集群管理，看看开源项目karmada是如何做到的">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Congrool.github.io/blog/2021/09/16/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%88%90%E5%91%98%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEkarmada%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/">多云环境下的成员集群管理，看看开源项目karmada是如何做到的</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4></h4>

            <p><strong>联系我们: 
                                    <p>团队负责人：丁轶群 yiqunding@zju.edu.cn</p>
                                    <p>网站维护人：刘佳文 839809484@qq.com</p>                
    </strong>

            

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020 SEL Laboratory , ZJ University all rights reserved.</p>
            
            <p class="pull-right">
               <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

               <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    


<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.min.js"></script>



<script src="/js/jquery.cookie.min.js"></script>
<script src="/js/jquery.waypoints.min.js"></script>
<script src="/js/jquery.counterup.min.js"></script>
<script src="/js/jquery-parallax.js"></script>


<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
