<!DOCTYPE html>
<html lang="zh-cn">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <title>Docker背后的内核知识——Namespace资源隔离</title>
  <meta name="author" content="孙健波" />
  
  
  
  
  <meta name="keywords" content="Docker, namespace">
  
  
  <meta name="description" content="本文从namespace使用的API开始，结合Docker逐步对六个namespace进行讲解。相信把讲解过程中所有的代码整合起来，你也能实现一个属于自己的“shell”容器了。虽然namespace技术使用起来非常简单，但是要真正把容器做到安全易用却并非易事。PID namespace中，我们要实现一个完善的init进程来维护好所有进程；network namespace中，我们还有复杂的路由表和iptables规则没有配置；user namespace中还有很多权限上的问题需要考虑等等。其中有些方面Docker已经做的很好，有些方面也才刚刚开始。希望通过本文，能为大家更好的理解Docker背后运行的原理提供帮助。">

  <meta name="generator" content="Hugo 0.68.3" />

  
  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  
  
  
  

  <link href="/css/all.css" rel="stylesheet">
  <link href="/css/bootstrap.min.css" rel="stylesheet">

  
  <link href="/css/animate.css" rel="stylesheet">

  
  
    <link href="/css/style.default.css" rel="stylesheet" id="theme-stylesheet">
  

  
  <link href="/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />

  
  <link href="/css/owl.carousel.css" rel="stylesheet">
  <link href="/css/owl.theme.css" rel="stylesheet">

  
  <link rel="alternate" href="https://Congrool.github.io/index.xml" type="application/rss+xml" title="浙大SEL实验室">

  
  
  
  
  
  
  <meta property="og:updated_time" content="2015-03-13T13:54:32Z">
  
    
    
    <meta property="article:section" content="Docker">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="namespace">
    
    
    <meta property="article:published_time" content="2015-03-13T13:54:32Z">
    <meta property="article:modified_time" content="2015-03-13T13:54:32Z">
  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Docker背后的内核知识——Namespace资源隔离">
  
  <meta name="twitter:description" content="本文从namespace使用的API开始，结合Docker逐步对六个namespace进行讲解。相信把讲解过程中所有的代码整合起来，你也能实现一个属于自己的“shell”容器了。虽然namespace技术使用起来非常简单，但是要真正把容器做到安全易用却并非易事。PID namespace中，我们要实现一个完善的init进程来维护好所有进程；network namespace中，我们还有复杂的路由表 …">
  
  
</head>


  <body>

    <div id="all">

        <header class="navbar-affixed-top" data-spy="affix" data-offset-top="62">
    <div class="navbar navbar-default yamm" role="navigation" id="navbar" style="background-color:white;">    
        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="/">
                    <img src="/img/sel.png" alt="Docker背后的内核知识——Namespace资源隔离" class="hidden-xs hidden-sm img-responsive">
                    
                    <span class="sr-only">Docker背后的内核知识——Namespace资源隔离 - </span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only"></span>
                        <i class="fas fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  
                  <li class="dropdown">
                    
                    <a href="/">主页</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">博客</a>
                    
                  </li>

                  <li class="dropdown">
                    
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">社区 <span class="caret"></span></a>
                  <ul class="dropdown-menu">
                    
                      <li><a href="https://www.servicemesher.com/">ServiceMesh社区</a></li>
                    
                      <li><a href="">kubeedge社区</a></li>

                      <li><a href="http://www.icsoft.zju.edu.cn/index.php">浙江大学智能计算与软件中心</a></li>
                    
                  </ul>

                  <li class="dropdown">
                    
                    <a href="/archives/">归档</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/contact/">关于</a>
                    
                  </li>
                  
                </li>

                
                

                
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">    
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main"><i class="fas fa-search"></i></button>
                </span>
                    </div>
                </form>
            </div>
            
        </div>
    </div>

    
</header>




        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Docker背后的内核知识——Namespace资源隔离</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                             <a href="#">孙健波</a>
                             | 
                            2015-03-13
                          </p>
                        

                        <div id="post-content">
                          <p>Docker这么火，喜欢技术的朋友可能也会想，如果要自己实现一个资源隔离的容器，应该从哪些方面下手呢？也许你第一反应可能就是<code>chroot</code>命令，这条命令给用户最直观的感觉就是使用后根目录<code>/</code>的挂载点切换了，即文件系统被隔离了。然后，为了在分布式的环境下进行通信和定位，容器必然需要一个独立的IP、端口、路由等等，自然就想到了网络的隔离。同时，你的容器还需要一个独立的主机名以便在网络中标识自己。想到网络，顺其自然就想到通信，也就想到了进程间通信的隔离。可能你也想到了权限的问题，对用户和用户组的隔离就实现了用户权限的隔离。最后，运行在容器中的应用需要有自己的<code>PID</code>,自然也需要与宿主机中的<code>PID</code>进行隔离。</p>

<p>由此，我们基本上完成了一个容器所需要做的六项隔离，Linux内核中就提供了这六种namespace隔离的系统调用，如下表所示。
<center>
<img src="https://res.cloudinary.com/rachel725/image/upload/v1605616383/sel/namespace_yaiofd.png" alt="" style="zoom:80%;" />
</center></p>

<p><strong>表1 namespace六项隔离</strong></p>

<p>实际上，Linux内核实现namespace的主要目的就是为了实现轻量级虚拟化（容器）服务。在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，仿佛自己置身于一个独立的系统环境中，以此达到独立和隔离的目的。</p>

<p>需要说明的是，本文所讨论的namespace实现针对的均是Linux内核3.8及其以后的版本。接下来，我们将首先介绍使用namespace的API，然后针对这六种namespace进行逐一讲解，并通过程序让你亲身感受一下这些隔离效果参考自<a href="http://lwn.net/Articles/531114/">http://lwn.net/Articles/531114/</a>。</p>

<h2 id="1-调用namespace的api"><strong>1. 调用namespace的API</strong></h2>

<p>namespace的API包括<code>clone()</code>、<code>setns()</code>以及<code>unshare()</code>，还有<code>/proc</code>下的部分文件。为了确定隔离的到底是哪种namespace，在使用这些API时，通常需要指定以下六个常数的一个或多个，通过<code>|（位或）</code>操作来实现。你可能已经在上面的表格中注意到，这六个参数分别是<code>CLONE_NEWIPC</code>、<code>CLONE_NEWNS</code>、<code>CLONE_NEWNET</code>、<code>CLONE_NEWPID</code>、 <code>CLONE_NEWUSER</code>和<code>CLONE_NEWUTS</code>。</p>

<h3 id="1-通过-clone-创建新进程的同时创建namespace"><strong>（1）通过<code>clone()</code>创建新进程的同时创建namespace</strong></h3>

<p>使用<code>clone()</code>来创建一个独立namespace的进程是最常见做法，它的调用方式如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">clone</span>(<span style="color:#078;font-weight:bold">int</span> (<span style="color:#555">*</span>child_func)(void <span style="color:#555">*</span>), void <span style="color:#555">*</span>child_stack, <span style="color:#078;font-weight:bold">int</span> flags, void <span style="color:#555">*</span>arg);</code></pre></div>
<p><code>clone()</code>实际上是传统UNIX系统调用<code>fork()</code>的一种更通用的实现方式，它可以通过<code>flags</code>来控制使用多少功能。一共有二十多种<code>CLONE_*</code>的<code>flag（标志位）</code>参数用来控制<code>clone</code>进程的方方面面（如是否与父进程共享虚拟内存等等），下面外面逐一讲解<code>clone</code>函数传入的参数。</p>

<ul>
<li>参数<code>child_func</code>传入子进程运行的程序主函数。</li>
<li>参数<code>child_stack</code>传入子进程使用的栈空间</li>
<li>参数<code>flags</code>表示使用哪些<code>CLONE_*</code>标志位</li>
<li>参数<code>args</code>则可用于传入用户参数</li>
</ul>

<p>在后续的内容中将会有使用<code>clone()</code>的实际程序可供大家参考。</p>

<h3 id="2-查看-proc-pid-ns文件"><strong>（2）查看/proc/[pid]/ns文件</strong></h3>

<p>从3.8版本的内核开始，用户就可以在<code>/proc/[pid]/ns</code>文件下看到指向不同namespace号的文件，效果如下所示，形如<code>[4026531839]</code>者即为namespace号。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ ls -l /proc/<span style="color:#033">$$</span>/ns         &lt;&lt;-- <span style="color:#033">$$</span> 表示应用的PID
total <span style="color:#f60">0</span>
lrwxrwxrwx. <span style="color:#f60">1</span> mtk mtk <span style="color:#f60">0</span> Jan  <span style="color:#f60">8</span> 04:12 ipc -&gt; ipc:<span style="color:#555">[</span>4026531839<span style="color:#555">]</span>
lrwxrwxrwx. <span style="color:#f60">1</span> mtk mtk <span style="color:#f60">0</span> Jan  <span style="color:#f60">8</span> 04:12 mnt -&gt; mnt:<span style="color:#555">[</span>4026531840<span style="color:#555">]</span>
lrwxrwxrwx. <span style="color:#f60">1</span> mtk mtk <span style="color:#f60">0</span> Jan  <span style="color:#f60">8</span> 04:12 net -&gt; net:<span style="color:#555">[</span>4026531956<span style="color:#555">]</span>
lrwxrwxrwx. <span style="color:#f60">1</span> mtk mtk <span style="color:#f60">0</span> Jan  <span style="color:#f60">8</span> 04:12 pid -&gt; pid:<span style="color:#555">[</span>4026531836<span style="color:#555">]</span>
lrwxrwxrwx. <span style="color:#f60">1</span> mtk mtk <span style="color:#f60">0</span> Jan  <span style="color:#f60">8</span> 04:12 user-&gt;user:<span style="color:#555">[</span>4026531837<span style="color:#555">]</span>
lrwxrwxrwx. <span style="color:#f60">1</span> mtk mtk <span style="color:#f60">0</span> Jan  <span style="color:#f60">8</span> 04:12 uts -&gt; uts:<span style="color:#555">[</span>4026531838<span style="color:#555">]</span></code></pre></div>
<p>如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。<code>/proc/[pid]/ns</code>的另外一个作用是，一旦文件被打开，只要打开的文件描述符（fd）存在，那么就算<code>PID</code>所属的所有进程都已经结束，创建的namespace就会一直存在。那如何打开文件描述符呢？把<code>/proc/[pid]/ns</code>目录挂载起来就可以达到这个效果，命令如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># touch ~/uts</span>
mount --bind /proc/27514/ns/uts ~/uts</code></pre></div>
<p>如果你看到的内容与本文所描述的不符，那么说明你使用的内核在3.8版本以前。该目录下存在的只有<code>ipc</code>、<code>net</code>和<code>uts</code>，并且以硬链接存在。</p>

<h3 id="3-通过-setns-加入一个已经存在的namespace"><strong>（3）通过<code>setns()</code>加入一个已经存在的namespace</strong></h3>

<p>上文刚提到，在进程都结束的情况下，也可以通过挂载的形式把namespace保留下来，保留namespace的目的自然是为以后有进程加入做准备。通过<code>setns()</code>系统调用，你的进程从原先的namespace加入我们准备好的新namespace，使用方法如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">setns</span>(<span style="color:#078;font-weight:bold">int</span> fd, <span style="color:#078;font-weight:bold">int</span> nstype);</code></pre></div>
<ul>
<li>参数<code>fd</code>表示我们要加入的namespace的文件描述符。上文已经提到，它是一个指向<code>/proc/[pid]/ns</code>目录的文件描述符，可以通过直接打开该目录下的链接或者打开一个挂载了该目录下链接的文件得到。</li>
<li>参数<code>nstype</code>让调用者可以去检查<code>fd</code>指向的namespace类型是否符合我们实际的要求。如果填<code>0</code>表示不检查。</li>
</ul>

<p>为了把我们创建的namespace利用起来，我们需要引入<code>execve()</code>系列函数，这个函数可以执行用户命令，最常用的就是调用<code>/bin/bash</code>并接受参数，运行起一个<code>shell</code>，用法如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#033">fd</span> <span style="color:#555">=</span> open<span style="color:#555">(</span>argv<span style="color:#555">[</span>1<span style="color:#555">]</span>, O_RDONLY<span style="color:#555">)</span>;   /* 获取namespace文件描述符 */
setns<span style="color:#555">(</span>fd, 0<span style="color:#555">)</span>;                   /* 加入新的namespace */
execvp<span style="color:#555">(</span>argv<span style="color:#555">[</span>2<span style="color:#555">]</span>, &amp;argv<span style="color:#555">[</span>2<span style="color:#555">])</span>;      /* 执行程序 */</code></pre></div>
<p>假设编译后的程序名称为<code>setns</code>。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ./setns ~/uts /bin/bash   # ~/uts 是绑定的/proc/27514/ns/uts</span></code></pre></div>
<p>至此，你就可以在新的命名空间中执行<code>shell</code>命令了，在下文中会多次使用这种方式来演示隔离的效果。</p>

<h3 id="4-通过-unshare-在原先进程上进行namespace隔离"><strong>（4）通过<code>unshare()</code>在原先进程上进行namespace隔离</strong></h3>

<p>最后要提的系统调用是<code>unshare()</code>，它跟<code>clone()</code>很像，不同的是，<code>unshare()</code>运行在原先的进程上，不需要启动一个新进程，使用方法如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">unshare</span>(<span style="color:#078;font-weight:bold">int</span> flags);</code></pre></div>
<p>调用<code>unshare()</code>的主要作用就是不启动一个新进程就可以起到隔离的效果，相当于跳出原先的namespace进行操作。这样，你就可以在原进程进行一些需要隔离的操作。Linux中自带的<code>unshare</code>命令，就是通过<code>unshare()</code>系统调用实现的，有兴趣的读者可以在网上搜索一下这个命令的作用。</p>

<h3 id="5-延伸阅读-fork-系统调用"><strong>（5）延伸阅读：<code>fork（）</code>系统调用</strong></h3>

<p>系统调用函数<code>fork()</code>并不属于namespace的API，所以这部分内容属于延伸阅读，如果读者已经对<code>fork()</code>有足够的了解，那大可跳过。 当程序调用<code>fork（）</code>函数时，系统会创建新的进程，为其分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中，只有少量数值与原来的进程值不同，相当于克隆了一个自己。那么程序的后续代码逻辑要如何区分自己是新进程还是父进程呢？ <code>fork()</code>的神奇之处在于它仅仅被调用一次，却能够返回两次（父进程与子进程各返回一次），通过返回值的不同就可以进行区分父进程与子进程。它可能有三种不同的返回值：</p>

<ul>
<li>在父进程中，fork返回新创建子进程的进程ID</li>
<li>在子进程中，fork返回0</li>
<li>如果出现错误，fork返回一个负值</li>
</ul>

<p>下面给出一段实例代码，命名为<code>fork_example.c</code>。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a00;background-color:#faa">#</span>include &lt;unistd.h&gt;
<span style="color:#a00;background-color:#faa">#</span>include &lt;stdio.h&gt;
<span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">main</span> (){
    pid_t fpid; <span style="color:#09f;font-style:italic">//fpid表示fork函数返回的值
</span><span style="color:#09f;font-style:italic"></span>    <span style="color:#078;font-weight:bold">int</span> count=<span style="color:#f60">0</span>;
    fpid=<span style="color:#c0f">fork</span>();
    <span style="color:#069;font-weight:bold">if</span> (fpid &lt; <span style="color:#f60">0</span>)<span style="color:#c0f">printf</span>(<span style="color:#c30">&#34;error in fork!&#34;</span>);
    <span style="color:#069;font-weight:bold">else</span> <span style="color:#069;font-weight:bold">if</span> (fpid <span style="color:#555">==</span> <span style="color:#f60">0</span>) {
        <span style="color:#c0f">printf</span>(<span style="color:#c30">&#34;I am child. Process id is %d/n&#34;</span>,<span style="color:#c0f">getpid</span>());
    }
    <span style="color:#069;font-weight:bold">else</span> {
        <span style="color:#c0f">printf</span>(<span style="color:#c30">&#34;i am parent. Process id is %d/n&#34;</span>,<span style="color:#c0f">getpid</span>());
    }
    <span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">0</span>;
}</code></pre></div>
<p>编译并执行，结果如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# gcc -Wall fork_example.c <span style="color:#555">&amp;&amp;</span> ./a.out
I am parent. Process id is <span style="color:#f60">28365</span>
I am child. Process id is <span style="color:#f60">28366</span></code></pre></div>
<p>使用<code>fork()</code>后，父进程有义务监控子进程的运行状态，并在子进程退出后自己才能正常退出，否则子进程就会成为“孤儿”进程。 下面我们将分别对六种namespace进行详细解析。</p>

<h2 id="2-uts-unix-time-sharing-system-namespace"><strong>2. UTS（UNIX Time-sharing System）namespace</strong></h2>

<p>UTS namespace提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点而非宿主机上的一个进程。 下面我们通过代码来感受一下UTS隔离的效果，首先需要一个程序的骨架，如下所示。打开编辑器创建<code>uts.c</code>文件，输入如下代码。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#099">#define _GNU_SOURCE
</span><span style="color:#099">#include</span> <span style="color:#099">&lt;sys/types.h&gt;</span><span style="color:#099">
</span><span style="color:#099">#include</span> <span style="color:#099">&lt;sys/wait.h&gt;</span><span style="color:#099">
</span><span style="color:#099">#include</span> <span style="color:#099">&lt;stdio.h&gt;</span><span style="color:#099">
</span><span style="color:#099">#include</span> <span style="color:#099">&lt;sched.h&gt;</span><span style="color:#099">
</span><span style="color:#099">#include</span> <span style="color:#099">&lt;signal.h&gt;</span><span style="color:#099">
</span><span style="color:#099">#include</span> <span style="color:#099">&lt;unistd.h&gt;</span><span style="color:#099">
</span><span style="color:#099"></span>
<span style="color:#099">#define STACK_SIZE (1024 * 1024)
</span><span style="color:#099"></span>
<span style="color:#069;font-weight:bold">static</span> <span style="color:#078;font-weight:bold">char</span> child_stack[STACK_SIZE];
<span style="color:#078;font-weight:bold">char</span><span style="color:#555">*</span> <span style="color:#069;font-weight:bold">const</span> child_args[] <span style="color:#555">=</span> {
  <span style="color:#c30">&#34;/bin/bash&#34;</span>,
  <span style="color:#366">NULL</span>
};

<span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">child_main</span>(<span style="color:#078;font-weight:bold">void</span><span style="color:#555">*</span> args) {
  printf(<span style="color:#c30">&#34;在子进程中!</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>);
  execv(child_args[<span style="color:#f60">0</span>], child_args);
  <span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">1</span>;
}

<span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">main</span>() {
  printf(<span style="color:#c30">&#34;程序开始: </span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>);
  <span style="color:#078;font-weight:bold">int</span> child_pid <span style="color:#555">=</span> clone(child_main, child_stack <span style="color:#555">+</span> STACK_SIZE, SIGCHLD, <span style="color:#366">NULL</span>);
  waitpid(child_pid, <span style="color:#366">NULL</span>, <span style="color:#f60">0</span>);
  printf(<span style="color:#c30">&#34;已退出</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>);
  <span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">0</span>;
}</code></pre></div>
<p>编译并运行上述代码，执行如下命令，效果如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# gcc -Wall uts.c -o uts.o <span style="color:#555">&amp;&amp;</span> ./uts.o
程序开始:
在子进程中!
root@local:~# <span style="color:#366">exit</span>
<span style="color:#366">exit</span>
已退出
root@local:~#</code></pre></div>
<p>下面，我们将修改代码，加入UTS隔离。<strong>运行代码需要root权限</strong>，为了防止普通用户任意修改系统主机名导致<code>set-user-ID</code>相关的应用运行出错。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">child_main</span>(<span style="color:#078;font-weight:bold">void</span><span style="color:#555">*</span> arg) {
  printf(<span style="color:#c30">&#34;在子进程中!</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>);
  sethostname(<span style="color:#c30">&#34;Changed Namespace&#34;</span>, <span style="color:#f60">12</span>);
  execv(child_args[<span style="color:#f60">0</span>], child_args);
  <span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">1</span>;
}

<span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">main</span>() {
<span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">int</span> child_pid <span style="color:#555">=</span> clone(child_main, child_stack<span style="color:#555">+</span>STACK_SIZE,
    CLONE_NEWUTS <span style="color:#555">|</span> SIGCHLD, <span style="color:#366">NULL</span>);
<span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span>}</code></pre></div>
<p>再次运行可以看到hostname已经变化。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# gcc -Wall namespace.c -o main.o <span style="color:#555">&amp;&amp;</span> ./main.o
程序开始:
在子进程中!
root@NewNamespace:~# <span style="color:#366">exit</span>
<span style="color:#366">exit</span>
已退出
root@local:~#  &lt;- 回到原来的hostname</code></pre></div>
<p>也许有读者试着不加<code>CLONE_NEWUTS</code>参数运行上述代码，发现主机名也变了，输入<code>exit</code>以后主机名也会变回来，似乎没什么区别。实际上不加<code>CLONE_NEWUTS</code>参数进行隔离而使用<code>sethostname</code>已经把宿主机的主机名改掉了。你看到<code>exit</code>退出后还原只是因为bash只在刚登录的时候读取一次UTS，当你重新登陆或者使用<code>uname</code>命令进行查看时，就会发现产生了变化。</p>

<p>Docker中，每个镜像基本都以自己所提供的服务命名了自己的hostname而没有对宿主机产生任何影响，用的就是这个原理。</p>

<h2 id="3-ipc-interprocess-communication-namespace"><strong>3. IPC（Interprocess Communication）namespace</strong></h2>

<p>容器中进程间通信采用的方法包括常见的信号量、消息队列和共享内存。然而与虚拟机不同的是，容器内部进程间通信对宿主机来说，实际上是具有相同PID namespace中的进程间通信，因此需要一个唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。</p>

<p>IPC namespace在代码上的变化与UTS namespace相似，只是标识位有所变化，需要加上<code>CLONE_NEWIPC</code>参数。主要改动如下，其他部位不变，程序名称改为<code>ipc.c</code>。测试方法参考自：<a href="http://crosbymichael.com/creating-containers-part-1.html">http://crosbymichael.com/creating-containers-part-1.html</a></p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">int</span> child_pid <span style="color:#555">=</span> clone(child_main, child_stack<span style="color:#555">+</span>STACK_SIZE,
          CLONE_NEWIPC <span style="color:#555">|</span> CLONE_NEWUTS <span style="color:#555">|</span> SIGCHLD, <span style="color:#366">NULL</span>);
<span style="color:#555">//</span>[...]</code></pre></div>
<p>我们首先在shell中使用<code>ipcmk -Q</code>命令创建一个message queue。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# ipcmk -Q</code></pre></div>
<p>通过<code>ipcs -q</code>可以查看到已经开启的message queue，序号为<code>32769</code>。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# ipcs -q
------ Message Queues --------
key        msqid   owner   perms   used-bytes   messages
0x4cf5e29f <span style="color:#f60">32769</span>   root    <span style="color:#f60">644</span>     <span style="color:#f60">0</span>            <span style="color:#f60">0</span></code></pre></div>
<p>然后我们可以编译运行加入了IPC namespace隔离的<code>ipc.c</code>，在新建的子进程中调用的<code>shell</code>中执行<code>ipcs -q</code>查看message queue。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# gcc -Wall ipc.c -o ipc.o <span style="color:#555">&amp;&amp;</span> ./ipc.o
程序开始:
在子进程中!
root@NewNamespace:~# ipcs -q
------ Message Queues --------
key   msqid   owner   perms   used-bytes   messages
root@NewNamespace:~# <span style="color:#366">exit</span>
<span style="color:#366">exit</span>
已退出</code></pre></div>
<p>上面的结果显示中可以发现，已经找不到原先声明的message queue，实现了IPC的隔离。 目前使用IPC namespace机制的系统不多，其中比较有名的有PostgreSQL。Docker本身通过socket或tcp进行通信。</p>

<h2 id="4-pid-namespace"><strong>4. PID namespace</strong></h2>

<p>PID namespace隔离非常实用，它对进程PID重新标号，即两个不同namespace下的进程可以有同一个PID。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。他创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace的parent namespace（树的父节点）。通过这种方式，不同的PID namespaces会形成一个等级体系。所属的父节点可以看到子节点中的进程，并可以通过信号量等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。由此产生如下结论。部分内容引自：<a href="http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part">http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part</a>。</p>

<ul>
<li>每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的<code>init</code>进程一样拥有特权，起特殊作用。</li>
<li>一个namespace中的进程，不可能通过<code>kill</code>或<code>ptrace</code>影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。</li>
<li>如果你在新的PID namespace中重新挂载<code>/proc</code>文件系统，会发现其下只显示同属一个PID namespace中的其他进程。</li>
<li>在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</li>
</ul>

<p>到这里，可能你已经联想到一种在外部监控Docker中运行程序的方法了，就是监控Docker Daemon所在的PID namespace下的所有进程即其子进程，再进行删选即可。 下面我们通过运行代码来感受一下PID namespace的隔离效果。修改上文的代码，加入PID namespace的标识位，并把程序命名为<code>pid.c</code>。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">int</span> child_pid <span style="color:#555">=</span> clone(child_main, child_stack<span style="color:#555">+</span>STACK_SIZE,
          CLONE_NEWPID <span style="color:#555">|</span> CLONE_NEWIPC <span style="color:#555">|</span> CLONE_NEWUTS 
          <span style="color:#555">|</span> SIGCHLD, <span style="color:#366">NULL</span>);
<span style="color:#555">//</span>[...]</code></pre></div>
<p>编译运行可以看到如下结果。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# gcc -Wall pid.c -o pid.o <span style="color:#555">&amp;&amp;</span> ./pid.o
程序开始:
在子进程中!
root@NewNamespace:~# <span style="color:#366">echo</span> <span style="color:#033">$$</span>
<span style="color:#f60">1</span>                      &lt;&lt;--注意此处看到shell的PID变成了1
root@NewNamespace:~# <span style="color:#366">exit</span>
<span style="color:#366">exit</span>
已退出</code></pre></div>
<p>打印<code>$$</code>可以看到shell的PID，退出后如果再次执行可以看到效果如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@local:~# <span style="color:#366">echo</span> <span style="color:#033">$$</span>
<span style="color:#f60">17542</span></code></pre></div>
<p>已经回到了正常状态。可能有的读者在子进程的shell中执行了<code>ps aux</code> <code>top</code>之类的命令，发现还是可以看到所有父进程的PID，那是因为我们还没有对文件系统进行隔离，<code>ps</code> <code>top</code>之类的命令调用的是真实系统下的<code>/proc</code>文件内容，看到的自然是所有的进程。 此外，与其他的namespace不同的是，为了实现一个稳定安全的容器，PID namespace还需要进行一些额外的工作才能确保其中的进程运行顺利。</p>

<h3 id="1-pid-namespace中的-init-进程">（1）PID namespace中的<code>init</code>进程</h3>

<p>当我们新建一个PID namespace时，默认启动的进程PID为<code>1</code>。我们知道，在传统的UNIX系统中，PID为<code>1</code>的进程是<code>init</code>，地位非常特殊。他作为所有进程的父进程，维护一张进程表，不断检查进程的状态，一旦有某个子进程因为程序错误成为了“孤儿”进程，<code>init</code>就会负责回收资源并结束这个子进程。所以在你要实现的容器中，启动的第一个进程也需要实现类似<code>init</code>的功能，维护所有后续启动进程的运行状态。</p>

<p>看到这里，可能读者已经明白了内核设计的良苦用心。PID namespace维护这样一个树状结构，非常有利于系统的资源监控与回收。Docker启动时，第一个进程也是这样，实现了进程监控和资源回收，它就是<code>dockerinit</code>。</p>

<h3 id="2-信号量与-init-进程">（2）信号量与<code>init</code>进程</h3>

<p>PID namespace中的<code>init</code>进程如此特殊，自然内核也为他赋予了特权——信号量屏蔽。如果<code>init</code>中没有写处理某个信号量的代码逻辑，那么与<code>init</code>在同一个PID namespace下的进程（即使有超级权限）发送给它的该信号量都会被屏蔽。这个功能的主要作用是防止<code>init</code>进程被误杀。</p>

<p>那么其父节点PID namespace中的进程发送同样的信号量会被忽略吗？父节点中的进程发送的信号量，如果不是<code>SIGKILL（销毁进程）</code>或<code>SIGSTOP（暂停进程）</code>也会被忽略。但如果发送<code>SIGKILL</code>或<code>SIGSTOP</code>，子节点的<code>init</code>会强制执行（无法通过代码捕捉进行特殊处理），也就是说父节点中的进程有权终止子节点中的进程。</p>

<p>一旦<code>init</code>进程被销毁，同一PID namespace中的其他进程也会随之接收到<code>SIGKILL</code>信号量而被销毁。理论上，该PID namespace自然也就不复存在了。但是如果<code>/proc/[pid]/ns/pid</code>处于被挂载或者打开状态，namespace就会被保留下来。然而，保留下来的namespace无法通过<code>setns()</code>或者<code>fork()</code>创建进程，所以实际上并没有什么作用。</p>

<p>我们常说，Docker一旦启动就有进程在运行，不存在不包含任何进程的Docker，也就是这个道理。</p>

<h3 id="3-挂载-proc-文件系统">（3）挂载<code>proc</code>文件系统</h3>

<p>前文中已经提到，如果你在新的PID namespace中使用<code>ps</code>命令查看，看到的还是所有的进程，因为与PID直接相关的<code>/proc</code>文件系统（<code>procfs</code>）没有挂载到与原<code>/proc</code>不同的位置。所以如果你只想看到PID namespace本身应该看到的进程，需要重新挂载<code>/proc</code>，命令如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">root@NewNamespace:~# mount -t proc proc /proc
root@NewNamespace:~# ps a
  PID TTY      STAT   TIME COMMAND
    <span style="color:#f60">1</span> pts/1    S      0:00 /bin/bash
  <span style="color:#f60">12</span> pts/1    R+     0:00 ps a</code></pre></div>
<p>可以看到实际的PID namespace就只有两个进程在运行。</p>

<p><strong>注意</strong>：因为此时我们没有进行mount namespace的隔离，所以这一步操作实际上已经影响了 root namespace的文件系统，当你退出新建的PID namespace以后再执行<code>ps a</code>就会发现出错，再次执行<code>mount -t proc proc /proc</code>可以修复错误。</p>

<h3 id="4-unshare-和-setns">（4）<code>unshare()</code>和<code>setns()</code></h3>

<p>在开篇我们就讲到了<code>unshare()</code>和<code>setns()</code>这两个API，而这两个API在PID namespace中使用时，也有一些特别之处需要注意。</p>

<p><code>unshare()</code>允许用户在原有进程中建立namespace进行隔离。但是创建了PID namespace后，原先<code>unshare()</code>调用者进程并不进入新的PID namespace，接下来创建的子进程才会进入新的namespace，这个子进程也就随之成为新namespace中的<code>init</code>进程。</p>

<p>类似的，调用<code>setns()</code>创建新PID namespace时，调用者进程也不进入新的PID namespace，而是随后创建的子进程进入。</p>

<p>为什么创建其他namespace时<code>unshare()</code>和<code>setns()</code>会直接进入新的namespace而唯独PID namespace不是如此呢？因为调用<code>getpid()</code>函数得到的PID是根据调用者所在的PID namespace而决定返回哪个PID，进入新的PID namespace会导致PID产生变化。而对用户态的程序和库函数来说，他们都认为进程的PID是一个常量，PID的变化会引起这些进程奔溃。</p>

<p>换句话说，<strong>一旦程序进程创建以后，那么它的PID namespace的关系就确定下来了，进程不会变更他们对应的PID namespace</strong>。</p>

<h2 id="5-mount-namespaces"><strong>5. Mount namespaces</strong></h2>

<p>Mount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，它是历史上第一个Linux namespace，所以它的标识位比较特殊，就是<code>CLONE_NEWNS</code>。隔离后，不同mount namespace中的文件结构发生变化也互不影响。你可以通过<code>/proc/[pid]/mounts</code>查看到所有挂载在当前namespace中的文件系统，还可以通过<code>/proc/[pid]/mountstats</code>看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等等。</p>

<p>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新namespace中的所有<code>mount</code>操作都只影响自身的文件系统，而对外界不会产生任何影响。这样做非常严格地实现了隔离，但是某些情况可能并不适用。比如父节点namespace中的进程挂载了一张CD-ROM，这时子节点namespace拷贝的目录结构就无法自动挂载上这张CD-ROM，因为这种操作会影响到父节点的文件系统。</p>

<p>2006 年引入的<strong>挂载传播（mount propagation）</strong>解决了这个问题，挂载传播定义了<strong>挂载对象（mount object）</strong>之间的关系，系统用这些关系决定任何挂载对象中的挂载事件如何传播到其他挂载对象参考自：<a href="http://www.ibm.com/developerworks/library/l-mount-namespaces/">http://www.ibm.com/developerworks/library/l-mount-namespaces/</a>。所谓传播事件，是指由一个挂载对象的状态变化导致的其它挂载对象的挂载与解除挂载动作的事件。</p>

<ul>
<li><strong>共享关系（share relationship）</strong>。如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然。</li>
<li><strong>从属关系（slave relationship）</strong>。如果两个挂载对象形成从属关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，但是反过来不行；在这种关系中，从属对象是事件的接收者。</li>
</ul>

<p>一个挂载状态可能为如下的其中一种：</p>

<ul>
<li>共享挂载（shared）</li>
<li>从属挂载（slave）</li>
<li>共享/从属挂载（shared and slave）</li>
<li>私有挂载（private）</li>
<li>不可绑定挂载（unbindable）</li>
</ul>

<p>传播事件的挂载对象称为<strong>共享挂载（shared mount）</strong>；接收传播事件的挂载对象称为<strong>从属挂载（slave mount）</strong>。既不传播也不接收传播事件的挂载对象称为<strong>私有挂载（private mount）</strong>。另一种特殊的挂载对象称为<strong>不可绑定的挂载（unbindable mount）</strong>，它们与私有挂载相似，但是不允许执行绑定挂载，即创建mount namespace时这块文件对象不可被复制。
<center>
<img src="https://res.cloudinary.com/rachel725/image/upload/v1605935606/sel/mountnamespace_pr7ui7.png" alt="" style="zoom:40%;" />
</center></p>

<p><strong>图1 mount各类挂载状态示意图</strong></p>

<p>共享挂载的应用场景非常明显，就是为了文件数据的共享所必须存在的一种挂载方式；从属挂载更大的意义在于某些“只读”场景；私有挂载其实就是纯粹的隔离，作为一个独立的个体而存在；不可绑定挂载则有助于防止没有必要的文件拷贝，如某个用户数据目录，当根目录被递归式的复制时，用户目录无论从隐私还是实际用途考虑都需要有一个不可被复制的选项。</p>

<p>默认情况下，所有挂载都是私有的。设置为共享挂载的命令如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mount --make-shared &lt;mount-object&gt;</code></pre></div>
<p>从共享挂载克隆的挂载对象也是共享的挂载；它们相互传播挂载事件。 设置为从属挂载的命令如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mount --make-slave &lt;shared-mount-object&gt;</code></pre></div>
<p>从从属挂载克隆的挂载对象也是从属的挂载，它也从属于原来的从属挂载的主挂载对象。 将一个从属挂载对象设置为共享/从属挂载，可以执行如下命令或者将其移动到一个共享挂载对象下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mount --make-shared &lt;slave-mount-object&gt;</code></pre></div>
<p>如果你想把修改过的挂载对象重新标记为私有的，可以执行如下命令。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mount --make-private &lt;mount-object&gt;</code></pre></div>
<p>通过执行以下命令，可以将挂载对象标记为不可绑定的。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">mount --make-unbindable &lt;mount-object&gt;</code></pre></div>
<p>这些设置都可以递归式地应用到所有子目录中，如果读者感兴趣可以搜索到相关的命令。 在代码中实现mount namespace隔离与其他namespace类似，加上<code>CLONE_NEWNS</code>标识位即可。让我们再次修改代码，并且另存为<code>mount.c</code>进行编译运行。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#09f;font-style:italic">//[...] 
</span><span style="color:#09f;font-style:italic"></span>      <span style="color:#078;font-weight:bold">int</span> child_pid <span style="color:#555">=</span> clone(child_main, child_stack<span style="color:#555">+</span>STACK_SIZE, CLONE_NEWNS <span style="color:#555">|</span> CLONE_NEWPID <span style="color:#555">|</span> CLONE_NEWIPC <span style="color:#555">|</span> CLONE_NEWUTS <span style="color:#555">|</span> SIGCHLD, <span style="color:#366">NULL</span>); 
    <span style="color:#555">//</span>[...] </code></pre></div>
<p>执行的效果就如同PID namespace一节中“挂载<code>proc</code>文件系统”的执行结果，区别就是退出mount namespace以后，root namespace的文件系统不会被破坏，此处就不再演示了。</p>

<h2 id="6-network-namespace"><strong>6. Network namespace</strong></h2>

<p>通过上节，我们了解了PID namespace，当我们兴致勃勃地在新建的namespace中启动一个“Apache”进程时，却出现了“80端口已被占用”的错误，原来主机上已经运行了一个“Apache”进程。怎么办？这就需要用到network namespace技术进行网络隔离啦。</p>

<p>Network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、<code>/proc/net</code>目录、<code>/sys/class/net</code>目录、端口（socket）等等。一个物理的网络设备最多存在在一个network namespace中，你可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然）在不同的network namespace间创建通道，以此达到通信的目的。</p>

<p>一般情况下，物理网络设备都分配在最初的root namespace（表示系统默认的namespace，在PID namespace中已经提及）中。但是如果你有多块物理网卡，也可以把其中一块或多块分配给新创建的network namespace。需要注意的是，当新创建的network namespace被释放时（所有内部的进程都终止并且namespace文件没有被挂载或打开），在这个namespace中的物理网卡会返回到root namespace而非创建该进程的父进程所在的network namespace。</p>

<p>当我们说到network namespace时，其实我们指的未必是真正的网络隔离，而是把网络独立出来，给外部用户一种透明的感觉，仿佛跟另外一个网络实体在进行通信。为了达到这个目的，容器的经典做法就是创建一个veth pair，一端放置在新的namespace中，通常命名为<code>eth0</code>，一端放在原先的namespace中连接物理网络设备，再通过网桥把别的设备连接进来或者进行路由转发，以此网络实现通信的目的。 也许有读者会好奇，在建立起veth pair之前，新旧namespace该如何通信呢？答案是<strong><code>pipe（管道）</code></strong>。我们以Docker Daemon在启动容器<code>dockerinit</code>的过程为例。</p>

<p>Docker Daemon在宿主机上负责创建这个<code>veth pair</code>，通过<code>netlink</code>调用，把一端绑定到<code>docker0</code>网桥上，一端连进新建的network namespace进程中。建立的过程中，<code>Docker Daemon</code>和<code>dockerinit</code>就通过<code>pipe</code>进行通信，当<code>Docker Daemon</code>完成<code>veth-pair</code>的创建之前，<code>dockerinit</code>在管道的另一端循环等待，直到管道另一端传来<code>Docker Daemon</code>关于<code>veth</code>设备的信息，并关闭管道。<code>dockerinit</code>才结束等待的过程，并把它的“<code>eth0</code>”启动起来。整个效果类似下图所示。
<center>
<img src="https://res.cloudinary.com/rachel725/image/upload/v1605936322/sel/network_tguj37.png" alt="" style="zoom:60%;" />
</center></p>

<p><strong>图2 Docker网络示意图</strong></p>

<p>跟其他namespace类似，对network namespace的使用其实就是在创建的时候添加<code>CLONE_NEWNET</code>标识位。也可以通过命令行工具<code>ip</code>创建network namespace。在代码中建立和测试network namespace较为复杂，所以下文主要通过<code>ip</code>命令直观的感受整个network namespace网络建立和配置的过程。</p>

<p>首先我们可以创建一个命名为<code>test_ns</code>的network namespace。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ip netns add test_ns</span></code></pre></div>
<p>当<code>ip</code>命令工具创建一个network namespace时，会默认创建一个回环设备（loopback interface：<code>lo</code>），并在<code>/var/run/netns</code>目录下绑定一个挂载点，这就保证了就算network namespace中没有进程在运行也不会被释放，也给系统管理员对新创建的network namespace进行配置提供了充足的时间。</p>

<p>通过<code>ip netns exec</code>命令可以在新创建的network namespace下运行网络管理命令。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ip netns exec test_ns ip link list</span>
3: lo: &lt;LOOPBACK&gt; mtu <span style="color:#f60">16436</span> qdisc noop state DOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</code></pre></div>
<p>上面的命令为我们展示了新建的namespace下可见的网络链接，可以看到状态是<code>DOWN</code>,需要再通过命令去启动。可以看到，此时执行<code>ping</code>命令是无效的。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ip netns exec test_ns ping 127.0.0.1</span>
connect: Network is unreachable</code></pre></div>
<p>启动命令如下，可以看到启动后再测试就可以ping通。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ip netns exec test_ns ip link set dev lo up</span>
<span style="color:#09f;font-style:italic"># ip netns exec test_ns ping 127.0.0.1</span>
PING 127.0.0.1 <span style="color:#555">(</span>127.0.0.1<span style="color:#555">)</span> 56<span style="color:#555">(</span>84<span style="color:#555">)</span> bytes of data.
<span style="color:#f60">64</span> bytes from 127.0.0.1: <span style="color:#033">icmp_req</span><span style="color:#555">=</span><span style="color:#f60">1</span> <span style="color:#033">ttl</span><span style="color:#555">=</span><span style="color:#f60">64</span> <span style="color:#033">time</span><span style="color:#555">=</span>0.050 ms
...</code></pre></div>
<p>这样只是启动了本地的回环，要实现与外部namespace进行通信还需要再建一个网络设备对，命令如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ip link add veth0 type veth peer name veth1</span>
<span style="color:#09f;font-style:italic"># ip link set veth1 netns test_ns</span>
<span style="color:#09f;font-style:italic"># ip netns exec test_ns ifconfig veth1 10.1.1.1/24 up</span>
<span style="color:#09f;font-style:italic"># ifconfig veth0 10.1.1.2/24 up</span></code></pre></div>
<ul>
<li>第一条命令创建了一个网络设备对，所有发送到<code>veth0</code>的包<code>veth1</code>也能接收到，反之亦然。</li>
<li>第二条命令则是把<code>veth1</code>这一端分配到<code>test_ns</code>这个network namespace。</li>
<li>第三、第四条命令分别给<code>test_ns</code>内部和外部的网络设备配置IP，<code>veth1</code>的IP为<code>10.1.1.1</code>，<code>veth0</code>的IP为<code>10.1.1.2</code>。</li>
</ul>

<p>此时两边就可以互相连通了，效果如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ping 10.1.1.1</span>
PING 10.1.1.1 <span style="color:#555">(</span>10.1.1.1<span style="color:#555">)</span> 56<span style="color:#555">(</span>84<span style="color:#555">)</span> bytes of data.
<span style="color:#f60">64</span> bytes from 10.1.1.1: <span style="color:#033">icmp_req</span><span style="color:#555">=</span><span style="color:#f60">1</span> <span style="color:#033">ttl</span><span style="color:#555">=</span><span style="color:#f60">64</span> <span style="color:#033">time</span><span style="color:#555">=</span>0.095 ms
...
<span style="color:#09f;font-style:italic"># ip netns exec test_ns ping 10.1.1.2</span>
PING 10.1.1.2 <span style="color:#555">(</span>10.1.1.2<span style="color:#555">)</span> 56<span style="color:#555">(</span>84<span style="color:#555">)</span> bytes of data.
<span style="color:#f60">64</span> bytes from 10.1.1.2: <span style="color:#033">icmp_req</span><span style="color:#555">=</span><span style="color:#f60">1</span> <span style="color:#033">ttl</span><span style="color:#555">=</span><span style="color:#f60">64</span> <span style="color:#033">time</span><span style="color:#555">=</span>0.049 ms
...</code></pre></div>
<p>读者有兴趣可以通过下面的命令查看，新的<code>test_ns</code>有着自己独立的路由和iptables。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic">#ip netns exec test_ns route</span>
<span style="color:#09f;font-style:italic">#ip netns exec test_ns iptables -L</span></code></pre></div>
<p>路由表中只有一条通向<code>10.1.1.2</code>的规则，此时如果要连接外网肯定是不可能的，你可以通过建立网桥或者NAT映射来决定这个问题。如果你对此非常感兴趣，可以阅读Docker网络相关文章进行更深入的讲解。</p>

<p>做完这些实验，你还可以通过下面的命令删除这个network namespace。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#09f;font-style:italic"># ip netns delete netns1</span></code></pre></div>
<p>这条命令会移除之前的挂载，但是如果namespace本身还有进程运行，namespace还会存在下去，直到进程运行结束。</p>

<p>通过network namespace我们可以了解到，实际上内核创建了network namespace以后，真的是得到了一个被隔离的网络。但是我们实际上需要的不是这种完全的隔离，而是一个对用户来说透明独立的网络实体，我们需要与这个实体通信。所以Docker的网络在起步阶段给人一种非常难用的感觉，因为一切都要自己去实现、去配置。你需要一个网桥或者NAT连接广域网，你需要配置路由规则与宿主机中其他容器进行必要的隔离，你甚至还需要配置防火墙以保证安全等等。所幸这一切已经有了较为成熟的方案，我们会在Docker网络部分进行详细的讲解。</p>

<h2 id="7-user-namespaces"><strong>7. User namespaces</strong></h2>

<p>User namespace主要隔离了安全相关的标识符（identifiers）和属性（attributes），包括用户ID、用户组ID、root目录、<a href="http://man7.org/linux/man-pages/man2/keyctl.2.html">key</a>（指密钥）以及<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">特殊权限</a>。说得通俗一点，一个普通用户的进程通过<code>clone()</code>创建的新进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特权的普通用户，但是他创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p>

<p>User namespace是目前的六个namespace中最后一个支持的，并且直到Linux内核3.8版本的时候还未完全实现（还有部分文件系统不支持）。因为user namespace实际上并不算完全成熟，很多发行版担心安全问题，在编译内核的时候并未开启<code>USER_NS</code>。<strong>实际上目前Docker也还不支持user namespace，但是预留了相应接口，相信在不久后就会支持这一特性。</strong> 所以在进行接下来的代码实验时，请确保你系统的Linux内核版本高于3.8并且内核编译时开启了<code>USER_NS</code>（如果你不会选择，可以使用Ubuntu14.04）。</p>

<p>Linux中，特权用户的user ID就是0，演示的最终我们将看到user ID非0的进程启动user namespace后user ID可以变为0。使用user namespace的方法跟别的namespace相同，即调用<code>clone()</code>或<code>unshare()</code>时加入<code>CLONE_NEWUSER</code>标识位。老样子，修改代码并另存为<code>userns.c</code>，为了看到用户<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">权限(Capabilities)</a>，可能你还需要安装一下<code>libcap-dev</code>包。</p>

<p>首先包含以下头文件以调用<code>Capabilities</code>包。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#099">#include</span> <span style="color:#099">&lt;sys/capability.h&gt;</span></code></pre></div>
<p>其次在子进程函数中加入<code>geteuid()</code>和<code>getegid()</code>得到namespace内部的user ID，其次通过<code>cap_get_proc()</code>得到当前进程的用户拥有的权限，并通过<code>cap_to_text（）</code>输出。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">child_main</span>(<span style="color:#078;font-weight:bold">void</span><span style="color:#555">*</span> args) {
        printf(<span style="color:#c30">&#34;在子进程中!</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>);
        cap_t caps;
        printf(<span style="color:#c30">&#34;eUID = %ld;  eGID = %ld;  &#34;</span>,
                        (<span style="color:#078;font-weight:bold">long</span>) geteuid(), (<span style="color:#078;font-weight:bold">long</span>) getegid());
        caps <span style="color:#555">=</span> cap_get_proc();
        printf(<span style="color:#c30">&#34;capabilities: %s</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>, cap_to_text(caps, <span style="color:#366">NULL</span>));
        execv(child_args[<span style="color:#f60">0</span>], child_args);
        <span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">1</span>;
}</code></pre></div>
<p>在主函数的<code>clone()</code>调用中加入我们熟悉的标识符。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">int</span> child_pid <span style="color:#555">=</span> clone(child_main, child_stack<span style="color:#555">+</span>STACK_SIZE,
            CLONE_NEWUSER <span style="color:#555">|</span> SIGCHLD, <span style="color:#366">NULL</span>);
<span style="color:#555">//</span>[...]</code></pre></div>
<p>至此，第一部分的代码修改就结束了。在编译之前我们先查看一下当前用户的<code>uid</code>和<code>guid</code>，请注意此时我们是普通用户。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ id -u
<span style="color:#f60">1000</span>
$ id -g
<span style="color:#f60">1000</span></code></pre></div>
<p>然后我们开始编译运行，并进行新建的user namespace，你会发现shell提示符前的用户名已经变为<code>nobody</code>。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">sun@ubuntu$ gcc userns.c -Wall -lcap -o userns.o <span style="color:#555">&amp;&amp;</span> ./userns.o
程序开始:
在子进程中!
<span style="color:#033">eUID</span> <span style="color:#555">=</span> 65534;  <span style="color:#033">eGID</span> <span style="color:#555">=</span> 65534;  capabilities: <span style="color:#555">=</span> cap_chown,cap_dac_override,<span style="color:#555">[</span>...<span style="color:#555">]</span>37+ep  &lt;&lt;--此处省略部分输出，已拥有全部权限
nobody@ubuntu$ </code></pre></div>
<p>通过验证我们可以得到以下信息。</p>

<ul>
<li>user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样这个<code>init</code>进程就可以完成所有必要的初始化工作，而不会因权限不足而出现错误。</li>
<li>我们看到namespace内部看到的UID和GID已经与外部不同了，默认显示为65534，表示尚未与外部namespace用户映射。我们需要对user namespace内部的这个初始user和其外部namespace某个用户建立映射，这样可以保证当涉及到一些对外部namespace的操作时，系统可以检验其权限（比如发送一个信号量或操作某个文件）。同样用户组也要建立映射。</li>
<li>还有一点虽然不能从输出中看出来，但是值得注意。用户在新namespace中有全部权限，但是他在创建他的父namespace中不含任何权限。就算调用和创建他的进程有全部权限也是如此。所以哪怕是root用户调用了<code>clone()</code>在user namespace中创建出的新用户在外部也没有任何权限。</li>
<li>最后，user namespace的创建其实是一个层层嵌套的树状结构。最上层的根节点就是root namespace，新创建的每个user namespace都有一个父节点user namespace以及零个或多个子节点user namespace，这一点与PID namespace非常相似。</li>
</ul>

<p>接下来我们就要进行用户绑定操作，通过在<code>/proc/[pid]/uid_map</code>和<code>/proc/[pid]/gid_map</code>两个文件中写入对应的绑定信息可以实现这一点，格式如下。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">ID<span style="color:#555">-</span>inside<span style="color:#555">-</span>ns   ID<span style="color:#555">-</span>outside<span style="color:#555">-</span>ns   length</code></pre></div>
<p>写这两个文件需要注意以下几点。</p>

<ul>
<li>这两个文件只允许由拥有该user namespace中<code>CAP_SETUID</code>权限的进程写入一次，不允许修改。</li>
<li>写入的进程必须是该user namespace的父namespace或者子namespace。</li>
<li>第一个字段<code>ID-inside-ns</code>表示新建的user namespace中对应的user/group ID，第二个字段<code>ID-outside-ns</code>表示namespace外部映射的user/group ID。最后一个字段表示映射范围，通常填1，表示只映射一个，如果填大于1的值，则按顺序建立一一映射。</li>
</ul>

<p>明白了上述原理，我们再次修改代码，添加设置uid和guid的函数。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#09f;font-style:italic">//[...]
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> <span style="color:#c0f">set_uid_map</span>(pid_t pid, <span style="color:#078;font-weight:bold">int</span> inside_id, <span style="color:#078;font-weight:bold">int</span> outside_id, <span style="color:#078;font-weight:bold">int</span> length) {
    <span style="color:#078;font-weight:bold">char</span> path[<span style="color:#f60">256</span>];
    sprintf(path, <span style="color:#c30">&#34;/proc/%d/uid_map&#34;</span>, getpid());
    FILE<span style="color:#555">*</span> uid_map <span style="color:#555">=</span> fopen(path, <span style="color:#c30">&#34;w&#34;</span>);
    fprintf(uid_map, <span style="color:#c30">&#34;%d %d %d&#34;</span>, inside_id, outside_id, length);
    fclose(uid_map);
}
<span style="color:#078;font-weight:bold">void</span> <span style="color:#c0f">set_gid_map</span>(pid_t pid, <span style="color:#078;font-weight:bold">int</span> inside_id, <span style="color:#078;font-weight:bold">int</span> outside_id, <span style="color:#078;font-weight:bold">int</span> length) {
    <span style="color:#078;font-weight:bold">char</span> path[<span style="color:#f60">256</span>];
    sprintf(path, <span style="color:#c30">&#34;/proc/%d/gid_map&#34;</span>, getpid());
    FILE<span style="color:#555">*</span> gid_map <span style="color:#555">=</span> fopen(path, <span style="color:#c30">&#34;w&#34;</span>);
    fprintf(gid_map, <span style="color:#c30">&#34;%d %d %d&#34;</span>, inside_id, outside_id, length);
    fclose(gid_map);
}
<span style="color:#078;font-weight:bold">int</span> <span style="color:#c0f">child_main</span>(<span style="color:#078;font-weight:bold">void</span><span style="color:#555">*</span> args) {
    cap_t caps;
    printf(<span style="color:#c30">&#34;在子进程中!</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>);
    set_uid_map(getpid(), <span style="color:#f60">0</span>, <span style="color:#f60">1000</span>, <span style="color:#f60">1</span>);
    set_gid_map(getpid(), <span style="color:#f60">0</span>, <span style="color:#f60">1000</span>, <span style="color:#f60">1</span>);
    printf(<span style="color:#c30">&#34;eUID = %ld;  eGID = %ld;  &#34;</span>,
            (<span style="color:#078;font-weight:bold">long</span>) geteuid(), (<span style="color:#078;font-weight:bold">long</span>) getegid());
    caps <span style="color:#555">=</span> cap_get_proc();
    printf(<span style="color:#c30">&#34;capabilities: %s</span><span style="color:#c30;font-weight:bold">\n</span><span style="color:#c30">&#34;</span>, cap_to_text(caps, <span style="color:#366">NULL</span>));
    execv(child_args[<span style="color:#f60">0</span>], child_args);
    <span style="color:#069;font-weight:bold">return</span> <span style="color:#f60">1</span>;
}
<span style="color:#555">//</span>[...]</code></pre></div>
<p>编译后即可看到user已经变成了<code>root</code>。</p>
<div class="highlight"><pre style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ gcc userns.c -Wall -lcap -o usernc.o <span style="color:#555">&amp;&amp;</span> ./usernc.o
程序开始:
在子进程中!
<span style="color:#033">eUID</span> <span style="color:#555">=</span> 0;  <span style="color:#033">eGID</span> <span style="color:#555">=</span> 0;  capabilities: <span style="color:#555">=</span> <span style="color:#555">[</span>...<span style="color:#555">]</span>,37+ep
root@ubuntu:~#</code></pre></div>
<p>至此，你就已经完成了绑定的工作，可以看到演示全程都是在普通用户下执行的。最终实现了在user namespace中成为了root而对应到外面的是一个uid为1000的普通用户。 如果你要把user namespace与其他namespace混合使用，那么依旧需要root权限。解决方案可以是先以普通用户身份创建user namespace，然后在新建的namespace中作为root再<code>clone()</code>进程加入其他类型的namespace隔离。</p>

<p>讲完了user namespace，我们再来谈谈Docker。虽然Docker目前尚未使用user namespace，但是他用到了我们在user namespace中提及的Capabilities机制。从内核2.2版本开始，Linux把原来和超级用户相关的高级权限划分成为不同的单元，称为Capability。这样管理员就可以独立对特定的Capability进行使能或禁止。Docker虽然没有使用user namespace，但是他可以禁用容器中不需要的Capability，一次在一定程度上加强容器安全性。</p>

<p>当然，说到安全，namespace的六项隔离看似全面，实际上依旧没有完全隔离Linux的资源，比如<code>SELinux</code>、 <code>Cgroups</code>以及<code>/sys</code>、<code>/proc/sys</code>、<code>/dev/sd*</code>等目录下的资源。关于安全的更多讨论和讲解，我们会在后文中接着探讨。</p>

<h2 id="8-总结"><strong>8. 总结</strong></h2>

<p>本文从namespace使用的API开始，结合Docker逐步对六个namespace进行讲解。相信把讲解过程中所有的代码整合起来，你也能实现一个属于自己的“shell”容器了。虽然namespace技术使用起来非常简单，但是要真正把容器做到安全易用却并非易事。PID namespace中，我们要实现一个完善的<code>init</code>进程来维护好所有进程；network namespace中，我们还有复杂的路由表和iptables规则没有配置；user namespace中还有很多权限上的问题需要考虑等等。其中有些方面Docker已经做的很好，有些方面也才刚刚开始。希望通过本文，能为大家更好的理解Docker背后运行的原理提供帮助。</p>
                        </div>
                        
                        
                        
                        
                        
                        

                        
                        <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                        <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script> 
                        <script type="text/javascript" src="/assets/js/md5.min.js"></script>
                        <div id="gitalk-container"></div>     
                        <script type="text/javascript">
                            var gitalk = new Gitalk({
                              clientID: '835183d2dcbd1167ac28', 
                            
                              clientSecret: 'd873919fac3cc76921ee0800172c2279bc612f8d', 
                            
                              repo: 'Sel-Website-talk',
                              owner: 'Peeknut',
                              admin: ['Peeknut','Rachel-Shao'],
                              id: location.href.split("/").pop().substring(0, 49),      
                              distractionFreeMode: false  
                            })
                            gitalk.render('gitalk-container')
                        </script> 
                        

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        

<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
      <h3 class="panel-title">搜索栏</h3>
      
    </div>

    <div class="panel-body">
        
        <div class="search" id="search">
            <div class="input-group">
                <input type="text" name="q" class="form-control" placeholder="请输入文章标题或摘要..." id="search-key">
                <input type="hidden" name="sitesearch" value="https://Congrool.github.io/">
                <span class="input-group-btn">
                    <button type="submit" class="btn btn-template-main" onclick="search()"><i class="fas fa-search"></i></button>
                </span>
            </div>
            <h1 id="search-tip" style="color: red;text-align: center;display: none;font-size: medium;">搜索中，请稍后 ...</h1>
        </div>
        <script type="text/javascript">
            
            window.onload = function() {
                      document.onkeydown = function(ev) {
                        var event = ev || event
                        if (event.keyCode == 13) {
                          search()
                        }
                      }
                    }
            
            function search() {
                    
                      key = document.getElementById("search-key").value;
                      if (key === "") {
                        
                        return;
                      }
                      key = key.toLowerCase();
                      document.getElementById("search-key").value = "";
                  
                      
                      document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
                      document.getElementById("search-tip").style.display = "block";
                  
                      
                      var el = document.getElementById('blog-listing-medium');
                      if (el == null) {
                        el = document.getElementById("blog-post")
                      }
                      var childs = el.childNodes;
                      for (var i = childs.length - 1; i >= 0; i--) {
                        el.removeChild(childs[i]);
                      }
                  
                      
                      xmltext = new XMLHttpRequest;
                      xmltext.open("GET", "/index.xml", false);
                      xmltext.send();
                      resp = xmltext.responseXML;
                      
                      items = resp.getElementsByTagName("item");
                      
                      var i = 0;
                      haveResult = false;
                      while (i < items.length) {
                        txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML
                        txt = txt.toLowerCase();
                        if (txt.indexOf(key) > -1) {
                          haveResult = true;
                          title = items[i].getElementsByTagName("title")[0].innerHTML;
                          link = items[i].getElementsByTagName("link")[0].innerHTML;
                          time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                          mark = items[i].getElementsByTagName("description")[0].innerHTML;
                          time = time.slice(0, -5);
                          addItem(title, link, time, mark)
                        }
                        i++;
                      }
                      if (!haveResult) {
                        document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
                        document.getElementById("search-tip").style.display = "block";
                      }

                      
                      var el = document.getElementById("blog-head");
                      el.innerHTML="Blogs"
                    }
                  
                    
                    function addItem(title, link, time, mark) {
                      document.getElementById("search-tip").style.display = "none";
                      tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
                        "<header class=\"post-header\">" +
                        "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
                        "<div class=\"post-meta\">" +
                        " <span class=\"post-time\">" + time + "</span>" +
                        "</div>" +
                        " </header>" +
                        "<div class=\"post-content\">" +
                        "<div class=\"post-summary\">" + mark + "</div>" +
                        "<div class=\"read-more\">" +
                        "<a href=" + link + " class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
                        "</div>" +
                        " </div>" +
                        "</article>"
                      div = document.createElement("div")
                      div.innerHTML = tmpl;
                      var el = document.getElementById('blog-listing-medium');
                      if (el == null) {
                        el = document.getElementById("blog-post")
                      }
                      el.appendChild(div)
                    }
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    

        </script>
        
    </div>
</div>







<div class="panel panel-default sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">归档栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            
            <li>
                <a href="/categories/bosh">bosh (1)</a>
            </li>
            
            <li>
                <a href="/categories/cloud_controller_ng">cloud_controller_ng (1)</a>
            </li>
            
            <li>
                <a href="/categories/cloudfoundry">cloudfoundry (15)</a>
            </li>
            
            <li>
                <a href="/categories/containerd">containerd (1)</a>
            </li>
            
            <li>
                <a href="/categories/docker">docker (19)</a>
            </li>
            
            <li>
                <a href="/categories/etcd">etcd (1)</a>
            </li>
            
            <li>
                <a href="/categories/haproxy">haproxy (1)</a>
            </li>
            
            <li>
                <a href="/categories/healthmanager">healthmanager (1)</a>
            </li>
            
            <li>
                <a href="/categories/karmada">karmada (4)</a>
            </li>
            
            <li>
                <a href="/categories/kubeedge">kubeedge (5)</a>
            </li>
            
            <li>
                <a href="/categories/kubernetes">kubernetes (14)</a>
            </li>
            
            <li>
                <a href="/categories/network">network (1)</a>
            </li>
            
            <li>
                <a href="/categories/openyurt">openyurt (2)</a>
            </li>
            
            <li>
                <a href="/categories/service-mesh">service-mesh (4)</a>
            </li>
            
        </ul>
    </div>

</div>








<div class="panel sidebar-menu">

    <div class="panel-heading">
        <h3 class="panel-title">标签栏</h3>
        
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            
            <li>
                <a href="/tags/agent"><i class="fas fa-tags"></i> agent</a>
            </li>
            
            <li>
                <a href="/tags/apiserver"><i class="fas fa-tags"></i> apiserver</a>
            </li>
            
            <li>
                <a href="/tags/books"><i class="fas fa-tags"></i> books</a>
            </li>
            
            <li>
                <a href="/tags/bosh"><i class="fas fa-tags"></i> bosh</a>
            </li>
            
            <li>
                <a href="/tags/ccng"><i class="fas fa-tags"></i> ccng</a>
            </li>
            
            <li>
                <a href="/tags/cf-release"><i class="fas fa-tags"></i> cf-release</a>
            </li>
            
            <li>
                <a href="/tags/cgroups"><i class="fas fa-tags"></i> cgroups</a>
            </li>
            
            <li>
                <a href="/tags/cloudfoundry"><i class="fas fa-tags"></i> cloudfoundry</a>
            </li>
            
            <li>
                <a href="/tags/cloudnative"><i class="fas fa-tags"></i> cloudnative</a>
            </li>
            
            <li>
                <a href="/tags/collector"><i class="fas fa-tags"></i> collector</a>
            </li>
            
            <li>
                <a href="/tags/containerd"><i class="fas fa-tags"></i> containerd</a>
            </li>
            
            <li>
                <a href="/tags/cri"><i class="fas fa-tags"></i> cri</a>
            </li>
            
            <li>
                <a href="/tags/dea"><i class="fas fa-tags"></i> dea</a>
            </li>
            
            <li>
                <a href="/tags/docker"><i class="fas fa-tags"></i> docker</a>
            </li>
            
            <li>
                <a href="/tags/docker-network"><i class="fas fa-tags"></i> docker-network</a>
            </li>
            
            <li>
                <a href="/tags/edgecomputing"><i class="fas fa-tags"></i> edgecomputing</a>
            </li>
            
            <li>
                <a href="/tags/etcd"><i class="fas fa-tags"></i> etcd</a>
            </li>
            
            <li>
                <a href="/tags/gorouter"><i class="fas fa-tags"></i> gorouter</a>
            </li>
            
            <li>
                <a href="/tags/haproxy"><i class="fas fa-tags"></i> haproxy</a>
            </li>
            
            <li>
                <a href="/tags/healthmanager"><i class="fas fa-tags"></i> healthmanager</a>
            </li>
            
            <li>
                <a href="/tags/istio"><i class="fas fa-tags"></i> istio</a>
            </li>
            
            <li>
                <a href="/tags/karmada"><i class="fas fa-tags"></i> karmada</a>
            </li>
            
            <li>
                <a href="/tags/kubeedge"><i class="fas fa-tags"></i> kubeedge</a>
            </li>
            
            <li>
                <a href="/tags/kubelet"><i class="fas fa-tags"></i> kubelet</a>
            </li>
            
            <li>
                <a href="/tags/kubernetes"><i class="fas fa-tags"></i> kubernetes</a>
            </li>
            
            <li>
                <a href="/tags/libcontainer"><i class="fas fa-tags"></i> libcontainer</a>
            </li>
            
            <li>
                <a href="/tags/micro-service"><i class="fas fa-tags"></i> micro-service</a>
            </li>
            
            <li>
                <a href="/tags/namespace"><i class="fas fa-tags"></i> namespace</a>
            </li>
            
            <li>
                <a href="/tags/nats"><i class="fas fa-tags"></i> nats</a>
            </li>
            
            <li>
                <a href="/tags/news"><i class="fas fa-tags"></i> news</a>
            </li>
            
            <li>
                <a href="/tags/openyurt"><i class="fas fa-tags"></i> openyurt</a>
            </li>
            
            <li>
                <a href="/tags/pipework"><i class="fas fa-tags"></i> pipework</a>
            </li>
            
            <li>
                <a href="/tags/pouch"><i class="fas fa-tags"></i> pouch</a>
            </li>
            
            <li>
                <a href="/tags/runc"><i class="fas fa-tags"></i> runc</a>
            </li>
            
            <li>
                <a href="/tags/runtime"><i class="fas fa-tags"></i> runtime</a>
            </li>
            
            <li>
                <a href="/tags/security"><i class="fas fa-tags"></i> security</a>
            </li>
            
            <li>
                <a href="/tags/serverless"><i class="fas fa-tags"></i> serverless</a>
            </li>
            
            <li>
                <a href="/tags/service-mesh"><i class="fas fa-tags"></i> service-mesh</a>
            </li>
            
            <li>
                <a href="/tags/syslog_aggregator"><i class="fas fa-tags"></i> syslog_aggregator</a>
            </li>
            
        </ul>
    </div>

</div>






                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        
        <div class="col-md-4 col-sm-6">
            <h4></h4>

            <p><strong>关于我们：<strong> <p>浙大SEL实验室</p><p>地址：杭州市浙大路38号曹光彪西楼405室</p><p><strong></strong>
            <a href="/contact" class="btn btn-small btn-template-main" >跳转到关于</a>

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

        <div class="col-md-4 col-sm-6">

             
            <h4>最新博客</h4>
            

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Congrool.github.io/blog/2022/08/26/%E5%9F%BA%E4%BA%8Ekubeedge%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
                          
                            <img src="/img/blogs/27/overview.png" class="img-responsive" alt="基于KubeEdge的边缘节点分组管理设计与实现">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Congrool.github.io/blog/2022/08/26/%E5%9F%BA%E4%BA%8Ekubeedge%E7%9A%84%E8%BE%B9%E7%BC%98%E8%8A%82%E7%82%B9%E5%88%86%E7%BB%84%E7%AE%A1%E7%90%86%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">基于KubeEdge的边缘节点分组管理设计与实现</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Congrool.github.io/blog/2021/09/22/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6karmada-scheduler%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/">
                          
                            <img src="/img/blogs/20/karmada-scheduler.png" class="img-responsive" alt="多云环境下的资源调度：karmada scheduler的框架和实现">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Congrool.github.io/blog/2021/09/22/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6karmada-scheduler%E7%9A%84%E6%A1%86%E6%9E%B6%E5%92%8C%E5%AE%9E%E7%8E%B0/">多云环境下的资源调度：karmada scheduler的框架和实现</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://Congrool.github.io/blog/2021/09/16/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%88%90%E5%91%98%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEkarmada%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/">
                          
                            <img src="/img/blogs/19/karmada-arch.jpg" class="img-responsive" alt="多云环境下的成员集群管理，看看开源项目karmada是如何做到的">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://Congrool.github.io/blog/2021/09/16/%E5%A4%9A%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%88%90%E5%91%98%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E7%9C%8B%E7%9C%8B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEkarmada%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E7%9A%84/">多云环境下的成员集群管理，看看开源项目karmada是如何做到的</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        
        <div class="col-md-4 col-sm-6">

          <h4></h4>

            <p><strong>联系我们: 
                                    <p>团队负责人：丁轶群 yiqunding@zju.edu.cn</p>
                                    <p>网站维护人：刘佳文 839809484@qq.com</p>                
    </strong>

            

            <hr class="hidden-md hidden-lg hidden-sm">

        </div>
        
        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright ©️ 2020 SEL Laboratory , ZJ University all rights reserved.</p>
            
            <p class="pull-right">
               <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

               <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    


<script src="/js/jquery.min.js"></script>
<script src="/js/bootstrap.min.js"></script>



<script src="/js/jquery.cookie.min.js"></script>
<script src="/js/jquery.waypoints.min.js"></script>
<script src="/js/jquery.counterup.min.js"></script>
<script src="/js/jquery-parallax.js"></script>


<script src="/js/front.js"></script>


<script src="/js/owl.carousel.min.js"></script>



  </body>
</html>
